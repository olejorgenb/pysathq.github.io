
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Hard formula generator (pysat.examples.genhard) &#8212; PySAT 0.1.5.dev1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Minimum/minimal hitting set solver (pysat.examples.hitman)" href="hitman.html" />
    <link rel="prev" title="Fu&amp;Malik MaxSAT algorithm (pysat.examples.fm)" href="fm.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-examples.genhard">
<span id="hard-formula-generator-pysat-examples-genhard"></span><h1>Hard formula generator (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.examples.genhard</span></code>)<a class="headerlink" href="#module-examples.genhard" title="Permalink to this headline">¶</a></h1>
<div class="section" id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#examples.genhard.CB" title="examples.genhard.CB"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CB</span></code></a></p></td>
<td><p>Mutilated chessboard principle (CB).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#examples.genhard.GT" title="examples.genhard.GT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GT</span></code></a></p></td>
<td><p>Generator of ordering (or <em>greater than</em>, GT) principle formulas.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#examples.genhard.PAR" title="examples.genhard.PAR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PAR</span></code></a></p></td>
<td><p>Generator of the parity principle (PAR) formulas.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#examples.genhard.PHP" title="examples.genhard.PHP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PHP</span></code></a></p></td>
<td><p>Generator of <span class="math notranslate nohighlight">\(k\)</span> pigeonhole principle (<span class="math notranslate nohighlight">\(k\)</span>-PHP) formulas.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">¶</a></h2>
<p>This module is designed to provide a few examples illustrating how PySAT
can be used for encoding practical problems into CNF formulas. These
include combinatorial principles that are widely studied from the
propositional proof complexity perspective. Namely, encodings for the
following principles are implemented: <em>pigeonhole principle</em> (<a class="reference internal" href="#examples.genhard.PHP" title="examples.genhard.PHP"><code class="xref py py-class docutils literal notranslate"><span class="pre">PHP</span></code></a>)
<a class="footnote-reference brackets" href="#id5" id="id1">1</a>, <em>ordering (greater-than) principle</em> (<a class="reference internal" href="#examples.genhard.GT" title="examples.genhard.GT"><code class="xref py py-class docutils literal notranslate"><span class="pre">GT</span></code></a>) <a class="footnote-reference brackets" href="#id6" id="id2">2</a>, <em>mutilated
chessboard principle</em> (<a class="reference internal" href="#examples.genhard.CB" title="examples.genhard.CB"><code class="xref py py-class docutils literal notranslate"><span class="pre">CB</span></code></a>) <a class="footnote-reference brackets" href="#id7" id="id3">3</a>, and <em>parity principle</em>
(<a class="reference internal" href="#examples.genhard.PAR" title="examples.genhard.PAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">PAR</span></code></a>) <a class="footnote-reference brackets" href="#id8" id="id4">4</a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Stephen A. Cook, Robert A. Reckhow. <em>The Relative Efficiency of
Propositional Proof Systems</em>. J. Symb. Log. 44(1). 1979. pp. 36-50</p>
</dd>
<dt class="label" id="id6"><span class="brackets">2</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p>Balakrishnan Krishnamurthy. <em>Short Proofs for Tricky Formulas</em>. Acta
Informatica 22(3). 1985. pp. 253-275</p>
</dd>
<dt class="label" id="id7"><span class="brackets">3</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id9">2</a>)</span></dt>
<dd><p>Michael Alekhnovich. <em>Mutilated Chessboard Problem Is Exponentially
Hard For Resolution</em>. Theor. Comput. Sci. 310(1-3). 2004. pp. 513-525</p>
</dd>
<dt class="label" id="id8"><span class="brackets">4</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id13">2</a>)</span></dt>
<dd><p>Miklós Ajtai. <em>Parity And The Pigeonhole Principle</em>. Feasible
Mathematics. 1990. pp. 1–24</p>
</dd>
</dl>
<p>The module can be used as an executable (the list of available command-line
options can be shown using <code class="docutils literal notranslate"><span class="pre">genhard.py</span> <span class="pre">-h</span></code>) in the following way</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ genhard.py -t php -n 3 -v
c PHP formula for 4 pigeons and 3 holes
c (pigeon, hole) pair: (1, 1); bool var: 1
c (pigeon, hole) pair: (1, 2); bool var: 2
c (pigeon, hole) pair: (1, 3); bool var: 3
c (pigeon, hole) pair: (2, 1); bool var: 4
c (pigeon, hole) pair: (2, 2); bool var: 5
c (pigeon, hole) pair: (2, 3); bool var: 6
c (pigeon, hole) pair: (3, 1); bool var: 7
c (pigeon, hole) pair: (3, 2); bool var: 8
c (pigeon, hole) pair: (3, 3); bool var: 9
c (pigeon, hole) pair: (4, 1); bool var: 10
c (pigeon, hole) pair: (4, 2); bool var: 11
c (pigeon, hole) pair: (4, 3); bool var: 12
p cnf 12 22
1 2 3 0
4 5 6 0
7 8 9 0
10 11 12 0
-1 -4 0
-1 -7 0
-1 -10 0
-4 -7 0
-4 -10 0
-7 -10 0
-2 -5 0
-2 -8 0
-2 -11 0
-5 -8 0
-5 -11 0
-8 -11 0
-3 -6 0
-3 -9 0
-3 -12 0
-6 -9 0
-6 -12 0
-9 -12 0
</pre></div>
</div>
<p>Alternatively, each of the considered problem encoders can be accessed with
the use of the standard <code class="docutils literal notranslate"><span class="pre">import</span></code> interface of Python, e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">PHP</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">PHP</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">12 22</span>
</pre></div>
</div>
<p>Given this example, observe that classes <a class="reference internal" href="#examples.genhard.PHP" title="examples.genhard.PHP"><code class="xref py py-class docutils literal notranslate"><span class="pre">PHP</span></code></a>, <a class="reference internal" href="#examples.genhard.GT" title="examples.genhard.GT"><code class="xref py py-class docutils literal notranslate"><span class="pre">GT</span></code></a>,
<a class="reference internal" href="#examples.genhard.CB" title="examples.genhard.CB"><code class="xref py py-class docutils literal notranslate"><span class="pre">CB</span></code></a>, and <a class="reference internal" href="#examples.genhard.PAR" title="examples.genhard.PAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">PAR</span></code></a> inherit from class
<a class="reference internal" href="../formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pysat.formula.CNF</span></code></a> and, thus, their corresponding clauses can
accessed through variable <code class="docutils literal notranslate"><span class="pre">.clauses</span></code>.</p>
</div>
<div class="section" id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="examples.genhard.CB">
<em class="property">class </em><code class="sig-prename descclassname">examples.genhard.</code><code class="sig-name descname">CB</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">exhaustive=False</em>, <em class="sig-param">topv=0</em>, <em class="sig-param">verb=False</em><span class="sig-paren">)</span><a class="headerlink" href="#examples.genhard.CB" title="Permalink to this definition">¶</a></dt>
<dd><p>Mutilated chessboard principle (CB). Given an integer <span class="math notranslate nohighlight">\(n\)</span>, the
principle states that it is impossible to cover a chessboard of size
<span class="math notranslate nohighlight">\(2n\cdot 2n\)</span> by domino tiles if two diagonally opposite corners
of the chessboard are removed.</p>
<p>Note that the chessboard has <span class="math notranslate nohighlight">\(4n^2-2\)</span> cells. Introduce a Boolean
variable <span class="math notranslate nohighlight">\(x_{ij}\)</span> for <span class="math notranslate nohighlight">\(i,j\in[4n^2-2]\)</span> s.t. cells <span class="math notranslate nohighlight">\(i\)</span>
and <span class="math notranslate nohighlight">\(j\)</span> are adjacent (no variables are introduced for pairs of
non-adjacent cells). CB formulas comprise clauses (1)
<span class="math notranslate nohighlight">\((\neg{x_{ji} \vee \neg{x_{ki}}})\)</span> for every <span class="math notranslate nohighlight">\(i,j \neq
k\)</span> meaning that no more than one adjacent cell can be paired with the
current one; and (2) <span class="math notranslate nohighlight">\((\vee_{j \in \text{Adj}(i)} {x_{ij}})\,\,
\forall i\)</span> enforcing that every cell <span class="math notranslate nohighlight">\(i\)</span> should be paired with
at least one adjacent cell.</p>
<p>Clearly, since the two diagonal corners are removed, the formula is
unsatisfiable. Also note the following. Assuming that the number of
black cells is larger than the number of the white ones, CB formulas
are unsatisfiable even if only a half of the formula is present, e.g.
when <span class="math notranslate nohighlight">\(\textsf{AtMost1}\)</span> constraints are formulated only for the
white cells while the <span class="math notranslate nohighlight">\(\textsf{AtLeast1}\)</span> constraints are
formulated only for the black cells. Depending on the value of
parameter <code class="docutils literal notranslate"><span class="pre">exhaustive</span></code> the encoder applies the <em>complete</em> or
<em>partial</em> formulation of the problem.</p>
<p>Mutilated chessboard principle is known to be hard for resolution <a class="footnote-reference brackets" href="#id7" id="id9">3</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – problem size (<span class="math notranslate nohighlight">\(n\)</span>)</p></li>
<li><p><strong>exhaustive</strong> (<em>bool</em>) – encode the problem exhaustively</p></li>
<li><p><strong>topv</strong> (<em>int</em>) – current top variable identifier</p></li>
<li><p><strong>verb</strong> (<em>bool</em>) – defines whether or not the encoder is verbose</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>object of class <a class="reference internal" href="../formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pysat.formula.CNF</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="examples.genhard.GT">
<em class="property">class </em><code class="sig-prename descclassname">examples.genhard.</code><code class="sig-name descname">GT</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">topv=0</em>, <em class="sig-param">verb=False</em><span class="sig-paren">)</span><a class="headerlink" href="#examples.genhard.GT" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator of ordering (or <em>greater than</em>, GT) principle formulas. Given
an integer parameter <span class="math notranslate nohighlight">\(n\)</span>, the principle states that any partial
order on the set <span class="math notranslate nohighlight">\(\{1,2,\ldots,n\}\)</span> must have a maximal element.</p>
<p>Assume variable <span class="math notranslate nohighlight">\(x_{ij}\)</span>, for <span class="math notranslate nohighlight">\(i,j\in[n],i\neq j\)</span>, denotes
the fact that <span class="math notranslate nohighlight">\(i \succ j\)</span>. Clauses <span class="math notranslate nohighlight">\((\neg{x_{ij}} \vee
\neg{x_{ji}})\)</span> and <span class="math notranslate nohighlight">\((\neg{x_{ij}} \vee \neg{x_{jk}} \vee
x_{ik})\)</span> ensure that the relation <span class="math notranslate nohighlight">\(\succ\)</span> is anti-symmetric and
transitive. As a result, <span class="math notranslate nohighlight">\(\succ\)</span> is a partial order on
<span class="math notranslate nohighlight">\([n]\)</span>. The additional requirement that each element <span class="math notranslate nohighlight">\(i\)</span> has
a successor in <span class="math notranslate nohighlight">\([n]\setminus\{i\}\)</span> represented a clause
<span class="math notranslate nohighlight">\((\vee_{j \neq i}{x_{ji}})\)</span> makes the formula unsatisfiable.</p>
<p>GT formulas were originally conjectured <a class="footnote-reference brackets" href="#id6" id="id10">2</a> to be hard for resolution.
However, <a class="footnote-reference brackets" href="#id12" id="id11">5</a> proved the existence of a polynomial size resolution
refutation for GT formulas.</p>
<dl class="footnote brackets">
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id11">5</a></span></dt>
<dd><p>Gunnar Stålmarck. <em>Short Resolution Proofs for a Sequence of
Tricky Formulas</em>. Acta Informatica. 33(3). 1996. pp. 277-280</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – number of elements (<span class="math notranslate nohighlight">\(n\)</span>)</p></li>
<li><p><strong>topv</strong> (<em>int</em>) – current top variable identifier</p></li>
<li><p><strong>verb</strong> (<em>bool</em>) – defines whether or not the encoder is verbose</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>object of class <a class="reference internal" href="../formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pysat.formula.CNF</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="examples.genhard.PAR">
<em class="property">class </em><code class="sig-prename descclassname">examples.genhard.</code><code class="sig-name descname">PAR</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">topv=0</em>, <em class="sig-param">verb=False</em><span class="sig-paren">)</span><a class="headerlink" href="#examples.genhard.PAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator of the parity principle (PAR) formulas. Given an integer
parameter <span class="math notranslate nohighlight">\(n\)</span>, the principle states that no graph on <span class="math notranslate nohighlight">\(2n+1\)</span>
nodes consists of a complete perfect matching.</p>
<p>The encoding of the parity principle uses <span class="math notranslate nohighlight">\(\binom{2n+1}{2}\)</span>
variables <span class="math notranslate nohighlight">\(x_{ij},i \neq j\)</span>. If variable <span class="math notranslate nohighlight">\(x_{ij}\)</span> is
<em>true</em>, then there is an edge between nodes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.
The formula consists of the following clauses: <span class="math notranslate nohighlight">\((\vee_{j \neq
i}{x_{ij}})\)</span> for every <span class="math notranslate nohighlight">\(i\in[2n+1]\)</span>, and <span class="math notranslate nohighlight">\((\neg{x_{ij}}
\vee \neg{x_{kj}})\)</span> for all distinct <span class="math notranslate nohighlight">\(i,j,k \in [2n+1]\)</span>.</p>
<p>The parity principle is known to be hard for resolution <a class="footnote-reference brackets" href="#id8" id="id13">4</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – problem size (<span class="math notranslate nohighlight">\(n\)</span>)</p></li>
<li><p><strong>topv</strong> (<em>int</em>) – current top variable identifier</p></li>
<li><p><strong>verb</strong> (<em>bool</em>) – defines whether or not the encoder is verbose</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>object of class <a class="reference internal" href="../formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pysat.formula.CNF</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="examples.genhard.PHP">
<em class="property">class </em><code class="sig-prename descclassname">examples.genhard.</code><code class="sig-name descname">PHP</code><span class="sig-paren">(</span><em class="sig-param">nof_holes</em>, <em class="sig-param">kval=1</em>, <em class="sig-param">topv=0</em>, <em class="sig-param">verb=False</em><span class="sig-paren">)</span><a class="headerlink" href="#examples.genhard.PHP" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator of <span class="math notranslate nohighlight">\(k\)</span> pigeonhole principle (<span class="math notranslate nohighlight">\(k\)</span>-PHP) formulas.
Given integer parameters <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(k\)</span>, the <span class="math notranslate nohighlight">\(k\)</span>
pigeonhole principle states that if <span class="math notranslate nohighlight">\(k\cdot m+1\)</span> pigeons are
distributes by <span class="math notranslate nohighlight">\(m\)</span> holes, then at least one hole contains more
than <span class="math notranslate nohighlight">\(k\)</span> pigeons.</p>
<p>Note that if <span class="math notranslate nohighlight">\(k\)</span> is 1, the principle degenerates to the
formulation of the original pigeonhole principle stating that
<span class="math notranslate nohighlight">\(m+1\)</span> pigeons cannot be distributed by <span class="math notranslate nohighlight">\(m\)</span> holes.</p>
<p>Assume that a Boolean variable <span class="math notranslate nohighlight">\(x_{ij}\)</span> encodes that pigeon
<span class="math notranslate nohighlight">\(i\)</span> resides in hole <span class="math notranslate nohighlight">\(j\)</span>. Then a PHP formula can be seen as
a conjunction: <span class="math notranslate nohighlight">\(\bigwedge_{i=1}^{k\cdot
m+1}{\textsf{AtLeast1}(x_{i1},\ldots,x_{im})}\wedge
\bigwedge_{j=1}^{m}{\textsf{AtMost}k(x_{1j},\ldots,x_{k\cdot
m+1,j})}\)</span>. Here each <span class="math notranslate nohighlight">\(\textsf{AtLeast1}\)</span> constraint forces every
pigeon to be placed into at least one hole while each
<span class="math notranslate nohighlight">\(\textsf{AtMost}k\)</span> constraint allows the corresponding hole to
have at most <span class="math notranslate nohighlight">\(k\)</span> pigeons. The overall PHP formulas are
unsatisfiable.</p>
<p>PHP formulas are well-known <a class="footnote-reference brackets" href="#id15" id="id14">6</a> to be hard for resolution.</p>
<dl class="footnote brackets">
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id14">6</a></span></dt>
<dd><p>Armin Haken. <em>The Intractability of Resolution</em>. Theor. Comput.
Sci. 39. 1985. pp. 297-308</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nof_holes</strong> (<em>int</em>) – number of holes (<span class="math notranslate nohighlight">\(n\)</span>)</p></li>
<li><p><strong>kval</strong> (<em>int</em>) – multiplier <span class="math notranslate nohighlight">\(k\)</span></p></li>
<li><p><strong>topv</strong> (<em>int</em>) – current top variable identifier</p></li>
<li><p><strong>verb</strong> (<em>bool</em>) – defines whether or not the encoder is verbose</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>object of class <a class="reference internal" href="../formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pysat.formula.CNF</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/pysat.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pysathq&repo=pysat&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div class="sidebarblock">
    <div class="tile">
    <h4>Latest version:</h4>
    0.1.5.dev1 (<a href="https://github.com/pysathq/pysat">GitHub</a>)
    </div>
    </br>
</div>
<div class="sidebarblock">
    <div class="tile">
    <h4><a href="https://pysathq.github.io">Main webpage</a></h4>
    </div>
</div>
</br>
<div class="sidebarblock">
<h4>Contact us:</h4>
      <a class="reference external" href="https://github.com/pysathq/pysat/issues">
            Issue tracker
      </a>
      |
      <a class="reference external" href="mailto:pysathq@gmail.com">
          Email
      </a>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2019, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/api/examples/genhard.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>