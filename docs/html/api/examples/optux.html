
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>OptUx optimal MUS enumerator (pysat.examples.optux) &#8212; PySAT 0.1.7.dev1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="RC2 MaxSAT solver (pysat.examples.rc2)" href="rc2.html" />
    <link rel="prev" title="A deletion-based MUS extractor (pysat.examples.musx)" href="musx.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-examples.optux">
<span id="optux-optimal-mus-enumerator-pysat-examples-optux"></span><h1>OptUx optimal MUS enumerator (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.examples.optux</span></code>)<a class="headerlink" href="#module-examples.optux" title="Permalink to this headline">¶</a></h1>
<div class="section" id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#examples.optux.OptUx" title="examples.optux.OptUx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OptUx</span></code></a></p></td>
<td><p>A simple Python version of the implicit hitting set based optimal MUS extractor and enumerator.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">¶</a></h2>
<p>An implementation of an extractor of a smallest size minimal unsatisfiable
subset (smallest MUS, or SMUS) <a class="footnote-reference brackets" href="#id7" id="id1">1</a> <a class="footnote-reference brackets" href="#id8" id="id2">2</a> <a class="footnote-reference brackets" href="#id9" id="id3">3</a> <a class="footnote-reference brackets" href="#id10" id="id4">4</a> and enumerator of
SMUSes based on <em>implicit hitting set enumeration</em> <a class="footnote-reference brackets" href="#id7" id="id5">1</a>. This
implementation tries to replicate the well-known SMUS extractor Forqes
<a class="footnote-reference brackets" href="#id7" id="id6">1</a>. In contrast to Forqes, this implementation supports not only plain
DIMACS <a class="reference internal" href="../formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> formulas but also weighted <a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> formulas.
As a result, the tool is able to compute and enumerate <em>optimal</em> MUSes in
case of weighted formulas. On the other hand, this prototype lacks a
number of command-line options used in Forqes and so it may be less
efficient compared to Forqes but the performance difference should not be
significant.</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id5">2</a>,<a href="#id6">3</a>,<a href="#id11">4</a>,<a href="#id12">5</a>)</span></dt>
<dd><p>Alexey Ignatiev, Alessandro Previti, Mark H. Liffiton, Joao
Marques-Silva. <em>Smallest MUS Extraction with Minimal Hitting Set
Dualization</em>. CP 2015. pp. 173-182</p>
</dd>
<dt class="label" id="id8"><span class="brackets">2</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id13">2</a>)</span></dt>
<dd><p>Mark H. Liffiton, Maher N. Mneimneh, Ines Lynce, Zaher S. Andraus,
Joao Marques-Silva, Karem A. Sakallah. <em>A branch and bound algorithm
for extracting smallest minimal unsatisfiable subformulas</em>.
Constraints An Int. J. 14(4). 2009. pp. 415-442</p>
</dd>
<dt class="label" id="id9"><span class="brackets">3</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id14">2</a>)</span></dt>
<dd><p>Alexey Ignatiev, Mikolas Janota, Joao Marques-Silva. <em>Quantified
Maximum Satisfiability: A Core-Guided Approach</em>. SAT 2013.
pp. 250-266</p>
</dd>
<dt class="label" id="id10"><span class="brackets">4</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id15">2</a>)</span></dt>
<dd><p>Alexey Ignatiev, Mikolas Janota, Joao Marques-Silva. <em>Quantified
maximum satisfiability</em>. Constraints An Int. J. 21(2). 2016.
pp. 277-302</p>
</dd>
</dl>
<p>The file provides a class <a class="reference internal" href="#examples.optux.OptUx" title="examples.optux.OptUx"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptUx</span></code></a>, which is the basic
implementation of the algorithm. It can be applied to any formula in the
<a class="reference internal" href="../formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> or <a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> format.</p>
<p>The implementation can be used as an executable (the list of available
command-line options can be shown using <code class="docutils literal notranslate"><span class="pre">optux.py</span> <span class="pre">-h</span></code>) in the following
way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ xzcat formula.wcnf.xz
p wcnf 3 6 4
1 1 0
1 2 0
1 3 0
4 -1 -2 0
4 -1 -3 0
4 -2 -3 0

$ optux.py -vvv formula.wcnf.xz
c mcs: 1 2 0
c mcses: 0 unit, 1 disj
c mus: 1 2 0
c cost: 2
c oracle time: 0.0001
</pre></div>
</div>
<p>Alternatively, the algorithm can be accessed and invoked through the
standard <code class="docutils literal notranslate"><span class="pre">import</span></code> interface of Python, e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.optux</span> <span class="kn">import</span> <span class="n">OptUx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;formula.wcnf.xz&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">OptUx</span><span class="p">(</span><span class="n">wcnf</span><span class="p">)</span> <span class="k">as</span> <span class="n">optux</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">optux</span><span class="o">.</span><span class="n">enumerate</span><span class="p">():</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mus </span><span class="si">{0}</span><span class="s1"> has cost </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">optux</span><span class="o">.</span><span class="n">cost</span><span class="p">))</span>
<span class="go">mus [1, 2] has cost 2</span>
<span class="go">mus [1, 3] has cost 2</span>
<span class="go">mus [2, 3] has cost 2</span>
</pre></div>
</div>
<p>As can be seen in the example above, the solver can be instructed either
to compute one optimal MUS of an input formula, or to enumerate a given
number (or <em>all</em>) of its top optimal MUSes.</p>
</div>
<div class="section" id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="examples.optux.OptUx">
<em class="property">class </em><code class="sig-prename descclassname">examples.optux.</code><code class="sig-name descname">OptUx</code><span class="sig-paren">(</span><em class="sig-param">formula</em>, <em class="sig-param">solver='g3'</em>, <em class="sig-param">adapt=False</em>, <em class="sig-param">exhaust=False</em>, <em class="sig-param">minz=False</em>, <em class="sig-param">trim=False</em>, <em class="sig-param">verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#examples.optux.OptUx" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple Python version of the implicit hitting set based optimal MUS
extractor and enumerator. Given a (weighted) (partial) CNF formula,
i.e. formula in the <a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> format, this class can be used to
compute a given number of optimal MUS (starting from the <em>best</em> one)
of the input formula. <a class="reference internal" href="#examples.optux.OptUx" title="examples.optux.OptUx"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptUx</span></code></a> roughly follows the
implementation of Forqes <a class="footnote-reference brackets" href="#id7" id="id11">1</a> but lacks a few additional heuristics,
which however aren’t applied in Forqes by default.</p>
<p>As a result, OptUx applies exhaustive <em>disjoint</em> minimal correction
subset (MCS) enumeration <a class="footnote-reference brackets" href="#id7" id="id12">1</a>, <a class="footnote-reference brackets" href="#id8" id="id13">2</a>, <a class="footnote-reference brackets" href="#id9" id="id14">3</a>, <a class="footnote-reference brackets" href="#id10" id="id15">4</a> with the incremental
use of RC2 <a class="footnote-reference brackets" href="#id18" id="id16">5</a> as an underlying MaxSAT solver. Once disjoint MCSes
are enumerated, they are used to bootstrap a hitting set solver. This
implementation uses <a class="reference internal" href="hitman.html#examples.hitman.Hitman" title="examples.hitman.Hitman"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hitman</span></code></a> as a hitting set solver, which is
again based on RC2.</p>
<p>Note that in the main implicit hitting enumeration loop of the
algorithm, OptUx follows Forqes in that it does not reduce correction
subsets detected to minimal correction subsets. As a result,
correction subsets computed in the main loop are added to
<code class="xref py py-class docutils literal notranslate"><span class="pre">Hitman</span></code> <em>unreduced</em>.</p>
<p><a class="reference internal" href="#examples.optux.OptUx" title="examples.optux.OptUx"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptUx</span></code></a> can use any SAT solver available in PySAT. The default
SAT solver to use is <code class="docutils literal notranslate"><span class="pre">g3</span></code>, which stands for Glucose 3 <a class="footnote-reference brackets" href="#id19" id="id17">6</a> (see
<a class="reference internal" href="../solvers.html#pysat.solvers.SolverNames" title="pysat.solvers.SolverNames"><code class="xref py py-class docutils literal notranslate"><span class="pre">SolverNames</span></code></a>). Boolean parameters <code class="docutils literal notranslate"><span class="pre">adapt</span></code>, <code class="docutils literal notranslate"><span class="pre">exhaust</span></code>, and
<code class="docutils literal notranslate"><span class="pre">minz</span></code> control whether or not the underlying <a class="reference internal" href="rc2.html#examples.rc2.RC2" title="examples.rc2.RC2"><code class="xref py py-class docutils literal notranslate"><span class="pre">RC2</span></code></a> oracles
should apply detection and adaptation of intrinsic AtMost1
constraints, core exhaustion, and core reduction. Also, unsatisfiable
cores can be trimmed if the <code class="docutils literal notranslate"><span class="pre">trim</span></code> parameter is set to a non-zero
integer. Finally, verbosity level can be set using the <code class="docutils literal notranslate"><span class="pre">verbose</span></code>
parameter.</p>
<dl class="footnote brackets">
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id16">5</a></span></dt>
<dd><p>Alexey Ignatiev, Antonio Morgado, Joao Marques-Silva. <em>RC2: an
Efficient MaxSAT Solver</em>. J. Satisf. Boolean Model. Comput. 11(1).
2019. pp. 53-64</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id17">6</a></span></dt>
<dd><p>Gilles Audemard, Jean-Marie Lagniez, Laurent Simon.
<em>Improving Glucose for Incremental SAT Solving with
Assumptions: Application to MUS Extraction</em>. SAT 2013.
pp. 309-317</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>) – (weighted) (partial) CNF formula</p></li>
<li><p><strong>solver</strong> (<em>str</em>) – SAT oracle name</p></li>
<li><p><strong>adapt</strong> (<em>bool</em>) – detect and adapt intrinsic AtMost1 constraints</p></li>
<li><p><strong>exhaust</strong> (<em>bool</em>) – do core exhaustion</p></li>
<li><p><strong>minz</strong> (<em>bool</em>) – do heuristic core reduction</p></li>
<li><p><strong>trim</strong> (<em>int</em>) – do core trimming at most this number of times</p></li>
<li><p><strong>verbose</strong> (<em>int</em>) – verbosity level</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="examples.optux.OptUx._disjoint">
<code class="sig-name descname">_disjoint</code><span class="sig-paren">(</span><em class="sig-param">formula</em>, <em class="sig-param">solver</em>, <em class="sig-param">adapt</em>, <em class="sig-param">exhaust</em>, <em class="sig-param">minz</em>, <em class="sig-param">trim</em><span class="sig-paren">)</span><a class="headerlink" href="#examples.optux.OptUx._disjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This method constitutes the preliminary step of the implicit
hitting set paradigm of Forqes. Namely, it enumerates all the
disjoint <em>minimal correction subsets</em> (MCSes) of the formula,
which will be later used to bootstrap the hitting set solver.</p>
<p>Note that the MaxSAT solver in use is <a class="reference internal" href="rc2.html#examples.rc2.RC2" title="examples.rc2.RC2"><code class="xref py py-class docutils literal notranslate"><span class="pre">RC2</span></code></a>. As a result,
all the input parameters of the method, namely, <code class="docutils literal notranslate"><span class="pre">formula</span></code>,
<code class="docutils literal notranslate"><span class="pre">solver</span></code>, <code class="docutils literal notranslate"><span class="pre">adapt</span></code>, <cite>exhaust`</cite>, <code class="docutils literal notranslate"><span class="pre">minz</span></code>, and <code class="docutils literal notranslate"><span class="pre">trim</span></code> -
represent the input and the options for the RC2 solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>) – input formula</p></li>
<li><p><strong>solver</strong> (<em>str</em>) – SAT solver name</p></li>
<li><p><strong>adapt</strong> (<em>bool</em>) – detect and adapt AtMost1 constraints</p></li>
<li><p><strong>exhaust</strong> (<em>bool</em>) – exhaust unsatisfiable cores</p></li>
<li><p><strong>minz</strong> (<em>bool</em>) – apply heuristic core minimization</p></li>
<li><p><strong>trim</strong> (<em>int</em>) – trim unsatisfiable cores at most this number of times</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="examples.optux.OptUx._process_soft">
<code class="sig-name descname">_process_soft</code><span class="sig-paren">(</span><em class="sig-param">formula</em><span class="sig-paren">)</span><a class="headerlink" href="#examples.optux.OptUx._process_soft" title="Permalink to this definition">¶</a></dt>
<dd><p>The method is for processing the soft clauses of the input
formula. Concretely, it checks which soft clauses must be relaxed
by a unique selector literal and applies the relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>formula</strong> (<a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>) – input formula</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="examples.optux.OptUx.compute">
<code class="sig-name descname">compute</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.optux.OptUx.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>This method implements the main look of the implicit hitting set
paradigm of Forqes to compute a best-cost MUS. The result MUS is
returned as a list of integers, each representing a soft clause
index.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(int)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="examples.optux.OptUx.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.optux.OptUx.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicit destructor of the internal hitting set and SAT oracles.</p>
</dd></dl>

<dl class="method">
<dt id="examples.optux.OptUx.enumerate">
<code class="sig-name descname">enumerate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.optux.OptUx.enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>This is generator method iterating through MUSes and enumerating
them until the formula has no more MUSes, or a user decides to
stop the process.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(int)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="examples.optux.OptUx.oracle_time">
<code class="sig-name descname">oracle_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.optux.OptUx.oracle_time" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes and returns the total SAT solving time
involved.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/pysat.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pysathq&repo=pysat&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div class="sidebarblock">
    <div class="tile">
    <h4>Latest version:</h4>
    0.1.7.dev1 (<a href="https://github.com/pysathq/pysat">GitHub</a>)
    </div>
    </br>
</div>
<div class="sidebarblock">
    <div class="tile">
    <h4><a href="https://pysathq.github.io">Main webpage</a></h4>
    </div>
</div>
</br>
<div class="sidebarblock">
<h4>Contact us:</h4>
      <a class="reference external" href="https://github.com/pysathq/pysat/issues">
            Issue tracker
      </a>
      |
      <a class="reference external" href="mailto:pysathq@gmail.com">
          Email
      </a>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2021, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/api/examples/optux.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>