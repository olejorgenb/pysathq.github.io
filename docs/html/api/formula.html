
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Boolean formula manipulation (pysat.formula) &#8212; PySAT 0.1.4.dev7 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Pseudo-Boolean encodings (pysat.pb)" href="pb.html" />
    <link rel="prev" title="Cardinality encodings (pysat.card)" href="card.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-pysat.formula">
<span id="boolean-formula-manipulation-pysat-formula"></span><h1>Boolean formula manipulation (<a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a>)<a class="headerlink" href="#module-pysat.formula" title="Permalink to this headline">¶</a></h1>
<div class="section" id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IDPool</span></code></a></td>
<td>A simple manager of variable IDs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNF</span></code></a></td>
<td>Class for manipulating CNF formulas.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNFPlus</span></code></a></td>
<td>CNF formulas augmented with <em>native</em> cardinality constraints.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WCNF</span></code></a></td>
<td>Class for manipulating partial (weighted) CNF formulas.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a></td>
<td>WCNF formulas augmented with <em>native</em> cardinality constraints.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">¶</a></h2>
<p>This module is designed to facilitate fast and easy PySAT-development by
providing a simple way to manipulate formulas in PySAT. Although only
clausal formulas are supported at this point, future releases of PySAT are
expected to implement data structures and methods to manipulate arbitrary
Boolean formulas. The module implements the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> class, which
represents a formula in <a class="reference external" href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive normal form (CNF)</a>.</p>
<p>Recall that a CNF formula is conventionally seen as a set of clauses, each
being a set of literals. A literal is a Boolean variable or its negation.
In PySAT, a Boolean variable and a literal should be specified as an
integer. For instance, a Boolean variable <span class="math notranslate nohighlight">\(x_{25}\)</span> is represented as
integer <code class="docutils literal notranslate"><span class="pre">25</span></code>. A literal <span class="math notranslate nohighlight">\(\neg{x_{10}}\)</span> should be specified as
<code class="docutils literal notranslate"><span class="pre">-10</span></code>. Moreover, a clause <span class="math notranslate nohighlight">\((\neg{x_2}\vee x_{19}\vee x_{46})\)</span>
should be specified as <code class="docutils literal notranslate"><span class="pre">[-2,</span> <span class="pre">19,</span> <span class="pre">46]</span></code> in PySAT. <em>Unit size clauses</em> are
to be specified as unit size lists as well, e.g. a clause <span class="math notranslate nohighlight">\((x_3)\)</span> is
a list <code class="docutils literal notranslate"><span class="pre">[3]</span></code>.</p>
<p>CNF formulas can be created as an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>. For
instance, the following piece of code creates a CNF formula
<span class="math notranslate nohighlight">\((\neg{x_1}\vee x_2)\wedge(\neg{x_2}\vee x_3)\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>The clauses of a formula can be accessed through the <code class="docutils literal notranslate"><span class="pre">clauses</span></code> variable
of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>, which is a list of lists of integers:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-1, 2], [-2 ,3]]</span>
</pre></div>
</div>
<p>The number of variables in a CNF formula, i.e. the <em>largest variable
identifier</em>, can be obtained using the <code class="docutils literal notranslate"><span class="pre">nv</span></code> variable, e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">nv</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> has a few methods to read and write a CNF formula into a
file or a string. The formula is read/written in the standard <a class="reference external" href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#SAT_problem_format">DIMACS CNF</a>
format. A clause in the DIMACS format is a string containing
space-separated integer literals  followed by <code class="docutils literal notranslate"><span class="pre">0</span></code>. For instance, a clause
<span class="math notranslate nohighlight">\((\neg{x_2}\vee x_{19}\vee x_{46})\)</span> is written as <code class="docutils literal notranslate"><span class="pre">-2</span> <span class="pre">19</span> <span class="pre">46</span> <span class="pre">0</span></code>
in DIMACS. The clauses in DIMACS should be preceded by a <em>preamble</em>, which
is a line <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">cnf</span> <span class="pre">nof_variables</span> <span class="pre">nof_clauses</span></code>, where <code class="docutils literal notranslate"><span class="pre">nof_variables</span></code> and
<code class="docutils literal notranslate"><span class="pre">nof_clauses</span></code> are integers. A preamble line for formula
<span class="math notranslate nohighlight">\((\neg{x_1}\vee x_2)\wedge(\neg{x_2}\vee x_3)\)</span> would be <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">cnf</span>
<span class="pre">3</span> <span class="pre">2</span></code>. The complete DIMACS file describing the formula looks this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="n">cnf</span> <span class="mi">3</span> <span class="mi">2</span>
<span class="o">-</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Reading and writing formulas in DIMACS can be done with PySAT in the
following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># reading from file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;another-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># reading from a file pointer</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">f2</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to a file pointer</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf 3 3</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">-2 3 0</span><span class="se">\n</span><span class="s1">-3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f3</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-1, 2], [-2, 3], [-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f3</span><span class="o">.</span><span class="n">nv</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Besides plain CNF formulas, the <a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a> module implements an
additional class for dealing with <em>partial</em> and <em>weighted partial</em> CNF
formulas, i.e. WCNF formulas. A WCNF formula is a conjunction of two sets
of clauses: <em>hard</em> clauses and <em>soft</em> clauses, i.e.
<span class="math notranslate nohighlight">\(\mathcal{F}=\mathcal{H}\wedge\mathcal{S}\)</span>. Soft clauses of a WCNF
are labeled with integer <em>weights</em>, i.e. a soft clause of
<span class="math notranslate nohighlight">\(\mathcal{S}\)</span> is a pair <span class="math notranslate nohighlight">\((c_i, w_i)\)</span>. In partial (unweighted)
formulas, all soft clauses have weight 1.</p>
<p>WCNF can be of help when solving optimization problems using the SAT
technology. A typical example of where a WCNF formula can be used is
<a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_satisfiability_problem">maximum satisfiability (MaxSAT)</a>, which
given a WCNF formula <span class="math notranslate nohighlight">\(\mathcal{F}=\mathcal{H}\wedge\mathcal{S}\)</span>
targets satisfying all its hard clauses <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> and maximizing
the sum of weights of satisfied soft clauses, i.e. maximizing the value of
<span class="math notranslate nohighlight">\(\sum_{c_i\in\mathcal{S}}{w_i\cdot c_i}\)</span>.</p>
<p>An object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> has two variables to access the hard and
soft clauses of the corresponding formula: <code class="docutils literal notranslate"><span class="pre">hard</span></code> and <code class="docutils literal notranslate"><span class="pre">soft</span></code>. The
weights of soft clauses are stored in variable <code class="docutils literal notranslate"><span class="pre">wght</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># the formula becomes unsatisfiable</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">hard</span>
<span class="go">[[-1, -2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">soft</span>
<span class="go">[[1], [2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
<p>A properly constructed WCNF formula must have a <em>top weight</em>, which should
be equal to <span class="math notranslate nohighlight">\(1+\sum_{c_i\in\mathcal{S}}{w_i}\)</span>. Top weight of a
formula can be accessed through variable <code class="docutils literal notranslate"><span class="pre">topw</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">topw</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># (1 + 3) + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">topw</span>
<span class="go">5</span>
</pre></div>
</div>
<p>Additionally to classes <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> and <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>, the module provides
the extended classes <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> and <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>. The only
difference between <code class="docutils literal notranslate"><span class="pre">?CNF</span></code> and <code class="docutils literal notranslate"><span class="pre">?CNFPlus</span></code> is the support for <em>native</em>
cardinality constraints provided by the <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard solver</a> (see <a class="reference internal" href="card.html#module-pysat.card" title="pysat.card"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code></a> for
details). The corresponding variable in objects of <code class="docutils literal notranslate"><span class="pre">CNFPlus</span></code>
(<code class="docutils literal notranslate"><span class="pre">WCNFPlus</span></code>, resp.) responsible for storing the AtMostK constraints is
<code class="docutils literal notranslate"><span class="pre">atmosts</span></code> (<code class="docutils literal notranslate"><span class="pre">atms</span></code>, resp.). <strong>Note</strong> that at this point, AtMostK
constraints in <code class="docutils literal notranslate"><span class="pre">WCNF</span></code> can be <em>hard</em> only.</p>
<p>Besides the implementations of CNF and WCNF formulas in PySAT, the
<a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a> module also provides a way to manage variable
identifiers. This can be done with the use of the <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a> manager.
With the use of the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> and <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> classes as well as with
the <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a> variable manager, it is pretty easy to develop
practical problem encoders into SAT or MaxSAT/MinSAT. As an example, a PHP
formula encoder is shown below (the implementation can also be found in
<a class="reference internal" href="examples/genhard.html#examples.genhard.PHP" title="examples.genhard.PHP"><code class="xref py py-class docutils literal notranslate"><span class="pre">examples.genhard.PHP</span></code></a>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>  <span class="c1"># we will store the formula here</span>

<span class="c1"># nof_holes is given</span>

<span class="c1"># initializing the pool of variable ids</span>
<span class="n">vpool</span> <span class="o">=</span> <span class="n">IDPool</span><span class="p">(</span><span class="n">start_from</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pigeon</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;pigeon{0}@{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

<span class="c1"># placing all pigeons into holes</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pigeon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

<span class="c1"># there cannot be more than 1 pigeon in a hole</span>
<span class="n">pigeons</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">pigeons</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="n">pigeon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pysat.formula.CNF">
<em class="property">class </em><code class="descclassname">pysat.formula.</code><code class="descname">CNF</code><span class="sig-paren">(</span><em>from_file=None, from_fp=None, from_string=None, from_clauses=[], comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for manipulating CNF formulas. It can be used for creating
formulas, reading them from a file, or writing them to a file. The
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code> parameter can be helpful when one needs to parse
specific comment lines starting not with character <code class="docutils literal notranslate"><span class="pre">c</span></code> but with
another character or a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>from_file</strong> (<em>str</em>) – a DIMACS CNF filename to read from</li>
<li><strong>from_fp</strong> (<em>file_pointer</em>) – a file pointer to read from</li>
<li><strong>from_string</strong> (<em>str</em>) – a string storing a CNF formula</li>
<li><strong>from_clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of clauses to bootstrap the formula with</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pysat.formula.CNF.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>clause</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add one more clause to CNF formula. This method additionally
updates the number of variables, i.e. variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in
the formula.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a new clause to add.</td>
</tr>
</tbody>
</table>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-1, 2], [3], [-3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be used for creating a copy of a CNF object. It
creates another object of the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> class and makes use of
the <em>deepcopy</em> functionality to copy the clauses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-1, 2], [1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>clauses</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Add several clauses to CNF formula. The clauses should be given in
the form of list. For every clause in the list, method
<a class="reference internal" href="#pysat.formula.CNF.append" title="pysat.formula.CNF.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> is invoked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of new clauses to add.</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-1, 2], [3], [-3, 4], [5, 6]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.from_clauses">
<code class="descname">from_clauses</code><span class="sig-paren">(</span><em>clauses</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_clauses" title="Permalink to this definition">¶</a></dt>
<dd><p>This methods copies a list of clauses into a CNF object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of clauses.</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-1, 2], [1, -2], [5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">nv</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.from_file">
<code class="descname">from_file</code><span class="sig-paren">(</span><em>fname, comment_lead=['c'], compressed_with='use_ext'</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a CNF formula from a file in the DIMACS format. A file name is
expected as an argument. A default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code> for
parsing comment lines. A given file can be compressed by either
gzip, bzip2, or lzma.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) – name of a file to parse.</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
<li><strong>compressed_with</strong> (<em>str</em>) – file compression algorithm</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compressed_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s1">&#39;some-file.cnf.gz&#39;</span><span class="p">,</span> <span class="n">compressed_with</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;another-file.cnf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.from_fp">
<code class="descname">from_fp</code><span class="sig-paren">(</span><em>file_pointer, comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_fp" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a CNF formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer to read the formula from.</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.from_string">
<code class="descname">from_string</code><span class="sig-paren">(</span><em>string, comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a CNF formula from a string. The string should be specified as
an argument and should be in the DIMACS CNF format. The only
default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing
specific comment lines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>string</strong> (<em>str</em>) – a string containing the formula in DIMACS.</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="o">=</span><span class="s1">&#39;p cnf 2 2</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">1 -2 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-1, 2], [1, -2]]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf 3 3</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">-2 3 0</span><span class="se">\n</span><span class="s1">-3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-1, 2], [-2, 3], [-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.negate">
<code class="descname">negate</code><span class="sig-paren">(</span><em>topv=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.negate" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a CNF formula <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>, this method creates a CNF
formula <span class="math notranslate nohighlight">\(\neg{\mathcal{F}}\)</span>. The negation of the formula is
encoded to CNF with the use of <em>auxiliary</em> Tseitin variables <a class="footnote-reference" href="#id2" id="id1">[1]</a>.
A new CNF formula is returned keeping all the newly introduced
variables that can be accessed through the <code class="docutils literal notranslate"><span class="pre">auxvars</span></code> variable.</p>
<p><strong>Note</strong> that the negation of each clause is encoded with one
auxiliary variable if it is not unit size. Otherwise, no auxiliary
variable is introduced.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>topv</strong> (<em>int</em>) – top variable identifier if any.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>G. S. Tseitin. <em>On the complexity of derivations in the
propositional calculus</em>.  Studies in Mathematics and
Mathematical Logic, Part II. pp.  115–125, 1968</td></tr>
</tbody>
</table>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neg</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">negate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">neg</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[1, -4], [-2, -4], [-1, 2, 4], [4, -3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">neg</span><span class="o">.</span><span class="n">auxvars</span>
<span class="go">[4, -3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.to_file">
<code class="descname">to_file</code><span class="sig-paren">(</span><em>fname</em>, <em>comments=None</em>, <em>compress_with='use_ext'</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The method is for saving a CNF formula into a file in the DIMACS
CNF format. A file name is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter. Also, a file can be compressed using either gzip, bzip2,
or lzma (xz).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) – a file name where to store the formula.</li>
<li><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</li>
<li><strong>compress_with</strong> (<em>str</em>) – file compression algorithm</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compress_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.to_fp">
<code class="descname">to_fp</code><span class="sig-paren">(</span><em>file_pointer</em>, <em>comments=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_fp" title="Permalink to this definition">¶</a></dt>
<dd><p>The method can be used to save a CNF formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) – a file name where to store the formula.</li>
<li><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNF.weighted">
<code class="descname">weighted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates a weighted copy of the internal formula. As a
result, an object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> is returned. Every clause
of the CNF formula is <em>soft</em> in the new WCNF formula and its weight
is equal to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The set of hard clauses of the formula is empty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">cnf</span><span class="o">.</span><span class="n">weighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">hard</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">soft</span>
<span class="go">[[-1, 2], [3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span>
<span class="go">[1, 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysat.formula.CNFPlus">
<em class="property">class </em><code class="descclassname">pysat.formula.</code><code class="descname">CNFPlus</code><span class="sig-paren">(</span><em>from_file=None, from_fp=None, from_string=None, comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus" title="Permalink to this definition">¶</a></dt>
<dd><p>CNF formulas augmented with <em>native</em> cardinality constraints.</p>
<p>This class inherits most of the functionality of the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>
class. The only difference between the two is that <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>
supports <em>native</em> cardinality constraints of <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard</a>.</p>
<p>The parser of input DIMACS files of <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> assumes the syntax
of AtMostK and AtLeastK constraints defined in the <a class="reference external" href="https://github.com/liffiton/minicard">description</a> of MiniCard:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span><span class="p">:</span> <span class="n">Two</span> <span class="n">cardinality</span> <span class="n">constraints</span> <span class="n">followed</span> <span class="n">by</span> <span class="n">a</span> <span class="n">clause</span>
<span class="n">p</span> <span class="n">cnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Each AtLeastK constraint is translated into an AtMostK constraint in
the standard way: <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\geq k \leftrightarrow
\sum_{i=1}^{n}{\neg{x_i}}\leq (n-k)\)</span>. Internally, AtMostK constraints
are stored in variable <code class="docutils literal notranslate"><span class="pre">atmosts</span></code>, each being a pair <code class="docutils literal notranslate"><span class="pre">(lits,</span> <span class="pre">k)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">lits</span></code> is a list of literals in the sum and <code class="docutils literal notranslate"><span class="pre">k</span></code> is the upper
bound.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf+ 7 3</span><span class="se">\n</span><span class="s1">1 -2 3 5 -7 &lt;= 3</span><span class="se">\n</span><span class="s1">4 5 6 -7 &gt;= 2</span><span class="se">\n</span><span class="s1"> 3 5 7 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[3, 5, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">atmosts</span>
<span class="go">[[[1, -2, 3, 5, -7], 3], [[-4, -5, -6, 7], 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">nv</span>
<span class="go">7</span>
</pre></div>
</div>
<p>For details on the functionality, see <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</p>
<dl class="method">
<dt id="pysat.formula.CNFPlus.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>clause</em>, <em>is_atmost=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single clause or a single AtMostK constraint to CNF+ formula.
This method additionally updates the number of variables, i.e.
variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in the formula.</p>
<p>If the clause is an AtMostK constraint, this should be set with the
use of the additional default argument <code class="docutils literal notranslate"><span class="pre">is_atmost</span></code>, which is set
to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a new clause to add.</li>
<li><strong>is_atmost</strong> (<em>bool</em>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the clause is AtMostK.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">atmosts</span>
<span class="go">[[1, 2, 3], 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNFPlus.from_fp">
<code class="descname">from_fp</code><span class="sig-paren">(</span><em>file_pointer, comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.from_fp" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a CNF+ formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer to read the formula from.</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.cnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.CNFPlus.to_fp">
<code class="descname">to_fp</code><span class="sig-paren">(</span><em>file_pointer</em>, <em>comments=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.to_fp" title="Permalink to this definition">¶</a></dt>
<dd><p>The method can be used to save a CNF+ formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) – a file name where to store the formula.</li>
<li><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysat.formula.IDPool">
<em class="property">class </em><code class="descclassname">pysat.formula.</code><code class="descname">IDPool</code><span class="sig-paren">(</span><em>start_from=1</em>, <em>occupied=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple manager of variable IDs. It can be used as a pool of integers
assigning an ID to any object. Identifiers are to start from <code class="docutils literal notranslate"><span class="pre">1</span></code> by
default. The list of occupied intervals is empty be default. If
necessary the top variable ID can be accessed directly using the
<code class="docutils literal notranslate"><span class="pre">top</span></code> variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>start_from</strong> (<em>int</em>) – the smallest ID to assign.</li>
<li><strong>occupied</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of occupied intervals.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pysat.formula.IDPool.id">
<code class="descname">id</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.id" title="Permalink to this definition">¶</a></dt>
<dd><p>The method is to be used to assign an integer variable ID for a
given new object. If the object already has an ID, no new ID is
created and the old one is returned instead.</p>
<p>An object can be anything. In some cases it is convenient to use
string variable names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>obj</strong> – an object to assign an ID to.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int.</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">IDPool</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vpool</span> <span class="o">=</span> <span class="n">IDPool</span><span class="p">(</span><span class="n">occupied</span><span class="o">=</span><span class="p">[[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># creating 5 unique variables for the following strings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;v{0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">11</span>
<span class="go">19</span>
<span class="go">20</span>
</pre></div>
</div>
<p>In some cases, it makes sense to create an external function for
accessing IDPool, e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># continuing the previous example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;var{0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;hello_world!&#39;</span><span class="p">)</span>
<span class="go">21</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.IDPool.obj">
<code class="descname">obj</code><span class="sig-paren">(</span><em>vid</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.obj" title="Permalink to this definition">¶</a></dt>
<dd><p>The method can be used to map back a given variable identifier to
the original object labeled by the identifier.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vid</strong> (<em>int</em>) – variable identifier.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">an object corresponding to the given identifier.</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vpool</span><span class="o">.</span><span class="n">obj</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">&#39;hello_world!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.IDPool.occupy">
<code class="descname">occupy</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.occupy" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a given interval as occupied so that the manager could skip
the values from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">stop</span></code> (<strong>inclusive</strong>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>start</strong> (<em>int</em>) – beginning of the interval.</li>
<li><strong>stop</strong> (<em>int</em>) – end of the interval.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.IDPool.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><em>start_from=1</em>, <em>occupied=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>Restart the manager from scratch. The arguments replicate those of
the constructor of <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysat.formula.WCNF">
<em class="property">class </em><code class="descclassname">pysat.formula.</code><code class="descname">WCNF</code><span class="sig-paren">(</span><em>from_file=None, from_fp=None, from_string=None, comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for manipulating partial (weighted) CNF formulas. It can be used
for creating formulas, reading them from a file, or writing them to a
file. The <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code> parameter can be helpful when one needs to
parse specific comment lines starting not with character <code class="docutils literal notranslate"><span class="pre">c</span></code> but with
another character or a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>from_file</strong> (<em>str</em>) – a DIMACS CNF filename to read from</li>
<li><strong>from_fp</strong> (<em>file_pointer</em>) – a file pointer to read from</li>
<li><strong>from_string</strong> (<em>str</em>) – a string storing a CNF formula</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pysat.formula.WCNF.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>clause</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add one more clause to WCNF formula. This method additionally
updates the number of variables, i.e. variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in
the formula.</p>
<p>The clause can be hard or soft depending on the <code class="docutils literal notranslate"><span class="pre">weight</span></code>
argument. If no weight is set, the clause is considered to be hard.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a new clause to add.</li>
<li><strong>weight</strong> (<em>integer</em><em> or </em><em>None</em>) – integer weight of the clause.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">hard</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">soft</span>
<span class="go">[[1], [-2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">wght</span>
<span class="go">[10, 20]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNF.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be used for creating a copy of a WCNF object. It
creates another object of the <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> class and makes use of
the <em>deepcopy</em> functionality to copy both hard and soft clauses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">hard</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">soft</span>
<span class="go">[[1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">wght</span>
<span class="go">[10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNF.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>clauses</em>, <em>weights=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Add several clauses to WCNF formula. The clauses should be given in
the form of list. For every clause in the list, method
<a class="reference internal" href="#pysat.formula.WCNF.append" title="pysat.formula.WCNF.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> is invoked.</p>
<p>The clauses can be hard or soft depending on the <code class="docutils literal notranslate"><span class="pre">weights</span></code>
argument. If no weights are set, the clauses are considered to be
hard.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of new clauses to add.</li>
<li><strong>weights</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a list of integer weights.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">]],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">hard</span>
<span class="go">[[-3, 4], [5, 6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">soft</span>
<span class="go">[[3], [-4], [-5], [-6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">wght</span>
<span class="go">[1, 5, 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNF.from_file">
<code class="descname">from_file</code><span class="sig-paren">(</span><em>fname, comment_lead=['c'], compressed_with='use_ext'</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a WCNF formula from a file in the DIMACS format. A file name
is expected as an argument. A default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>
for parsing comment lines. A given file can be compressed by either
gzip, bzip2, or lzma.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) – name of a file to parse.</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
<li><strong>compressed_with</strong> (<em>str</em>) – file compression algorithm</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compressed_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf.bz2&#39;</span><span class="p">,</span> <span class="n">compressed_with</span><span class="o">=</span><span class="s1">&#39;bzip2&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;another-file.wcnf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNF.from_fp">
<code class="descname">from_fp</code><span class="sig-paren">(</span><em>file_pointer, comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.from_fp" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a WCNF formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer to read the formula from.</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNF.from_string">
<code class="descname">from_string</code><span class="sig-paren">(</span><em>string, comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a WCNF formula from a string. The string should be specified
as an argument and should be in the DIMACS CNF format. The only
default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing
specific comment lines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>string</strong> (<em>str</em>) – a string containing the formula in DIMACS.</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="o">=</span><span class="s1">&#39;p wcnf 2 2 2</span><span class="se">\n</span><span class="s1"> 2 -1 2 0</span><span class="se">\n</span><span class="s1">1 1 -2 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">hard</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">soft</span>
<span class="go">[[1, 2]]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p wcnf 3 3 2</span><span class="se">\n</span><span class="s1">2 -1 2 0</span><span class="se">\n</span><span class="s1">2 -2 3 0</span><span class="se">\n</span><span class="s1">1 -3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">hard</span>
<span class="go">[[-1, 2], [-2, 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">soft</span>
<span class="go">[[-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNF.to_file">
<code class="descname">to_file</code><span class="sig-paren">(</span><em>fname</em>, <em>comments=None</em>, <em>compress_with='use_ext'</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The method is for saving a WCNF formula into a file in the DIMACS
CNF format. A file name is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter. Also, a file can be compressed using either gzip, bzip2,
or lzma (xz).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) – a file name where to store the formula.</li>
<li><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</li>
<li><strong>compress_with</strong> (<em>str</em>) – file compression algorithm</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compress_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;some-file-name.wcnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNF.to_fp">
<code class="descname">to_fp</code><span class="sig-paren">(</span><em>file_pointer</em>, <em>comments=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_fp" title="Permalink to this definition">¶</a></dt>
<dd><p>The method can be used to save a WCNF formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) – a file name where to store the formula.</li>
<li><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">wcnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNF.unweighed">
<code class="descname">unweighed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.unweighed" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates a <em>plain</em> (unweighted) copy of the internal
formula. As a result, an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> is returned.
Every clause (both hard or soft) of the WCNF formula is copied to
the <code class="docutils literal notranslate"><span class="pre">clauses</span></code> variable of the resulting plain formula, i.e. all
weights are discarded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">]],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">unweighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-3, 4], [5, 6], [3], [-4], [-5], [-6]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysat.formula.WCNFPlus">
<em class="property">class </em><code class="descclassname">pysat.formula.</code><code class="descname">WCNFPlus</code><span class="sig-paren">(</span><em>from_file=None, from_fp=None, from_string=None, comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus" title="Permalink to this definition">¶</a></dt>
<dd><p>WCNF formulas augmented with <em>native</em> cardinality constraints.</p>
<p>This class inherits most of the functionality of the <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>
class. The only difference between the two is that <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>
supports <em>native</em> cardinality constraints of <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard</a>.</p>
<p>The parser of input DIMACS files of <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a> assumes the
syntax of AtMostK and AtLeastK constraints following the one defined
for <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> in the <a class="reference external" href="https://github.com/liffiton/minicard">description</a> of MiniCard:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span><span class="p">:</span> <span class="n">Two</span> <span class="p">(</span><span class="n">hard</span><span class="p">)</span> <span class="n">cardinality</span> <span class="n">constraints</span> <span class="n">followed</span> <span class="n">by</span> <span class="n">a</span> <span class="n">soft</span> <span class="n">clause</span>
<span class="n">p</span> <span class="n">wcnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span> <span class="mi">10</span>
<span class="mi">10</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">10</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">5</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p><strong>Note</strong> that every cardinality constraint is assumed to be hard, i.e.
soft cardinality constraints are currently <em>not supported</em>.</p>
<p>Each AtLeastK constraint is translated into an AtMostK constraint in
the standard way: <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\geq k \leftrightarrow
\sum_{i=1}^{n}{\neg{x_i}}\leq (n-k)\)</span>. Internally, AtMostK constraints
are stored in variable <code class="docutils literal notranslate"><span class="pre">atms</span></code>, each being a pair <code class="docutils literal notranslate"><span class="pre">(lits,</span> <span class="pre">k)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">lits</span></code> is a list of literals in the sum and <code class="docutils literal notranslate"><span class="pre">k</span></code> is the upper bound.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p wcnf+ 7 3 10</span><span class="se">\n</span><span class="s1">10 1 -2 3 5 -7 &lt;= 3</span><span class="se">\n</span><span class="s1">10 4 5 6 -7 &gt;= 2</span><span class="se">\n</span><span class="s1">5 3 5 7 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">soft</span>
<span class="go">[[3, 5, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">wght</span>
<span class="go">[5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">hard</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">atms</span>
<span class="go">[[[1, -2, 3, 5, -7], 3], [[-4, -5, -6, 7], 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">nv</span>
<span class="go">7</span>
</pre></div>
</div>
<p>For details on the functionality, see <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>.</p>
<dl class="method">
<dt id="pysat.formula.WCNFPlus.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>clause</em>, <em>weight=None</em>, <em>is_atmost=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single clause or a single AtMostK constraint to WCNF+
formula. This method additionally updates the number of variables,
i.e.  variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in the formula.</p>
<p>If the clause is an AtMostK constraint, this should be set with the
use of the additional default argument <code class="docutils literal notranslate"><span class="pre">is_atmost</span></code>, which is set
to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">is_atmost</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the clause can be either hard
or soft depending on the <code class="docutils literal notranslate"><span class="pre">weight</span></code> argument. If no weight is
specified, the clause is considered hard. Otherwise, the clause is
soft.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a new clause to add.</li>
<li><strong>weight</strong> (<em>integer</em><em> or </em><em>None</em>) – an integer weight of the clause.</li>
<li><strong>is_atmost</strong> (<em>bool</em>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the clause is AtMostK.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">hard</span>
<span class="go">[[-3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">atms</span>
<span class="go">[[1, 2, 3], 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">soft</span>
<span class="go">[[-1, -2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">wght</span>
<span class="go">[35]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNFPlus.from_fp">
<code class="descname">from_fp</code><span class="sig-paren">(</span><em>file_pointer, comment_lead=['c']</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.from_fp" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a WCNF+ formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer to read the formula from.</li>
<li><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.wcnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.formula.WCNFPlus.to_fp">
<code class="descname">to_fp</code><span class="sig-paren">(</span><em>file_pointer</em>, <em>comments=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.to_fp" title="Permalink to this definition">¶</a></dt>
<dd><p>The method can be used to save a WCNF+ formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) – a file name where to store the formula.</li>
<li><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/pysat.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pysathq&repo=pysat&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div class="sidebarblock">
    <div class="tile">
    <h4>Latest version:</h4>
    0.1.4.dev7 (<a href="https://github.com/pysathq/pysat">GitHub</a>)
    </div>
    </br>
</div>
<div class="sidebarblock">
    <div class="tile">
    <h4><a href="https://pysathq.github.io">Main webpage</a></h4>
    </div>
</div>
</br>
<div class="sidebarblock">
<h4>Contact us:</h4>
      <a class="reference external" href="https://github.com/pysathq/pysat/issues">
            Issue tracker
      </a>
      |
      <a class="reference external" href="mailto:pysathq@gmail.com">
          Email
      </a>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2019, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/api/formula.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>