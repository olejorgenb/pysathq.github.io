
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Boolean formula manipulation (pysat.formula) &#8212; PySAT 0.1.5.dev12 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Pseudo-Boolean encodings (pysat.pb)" href="pb.html" />
    <link rel="prev" title="Cardinality encodings (pysat.card)" href="card.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-pysat.formula">
<span id="boolean-formula-manipulation-pysat-formula"></span><h1>Boolean formula manipulation (<a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a>)<a class="headerlink" href="#module-pysat.formula" title="Permalink to this headline">¶</a></h1>
<div class="section" id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">IDPool</span></code></p></td>
<td><p>A simple manager of variable IDs.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNF</span></code></p></td>
<td><p>Class for manipulating CNF formulas.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNFPlus</span></code></p></td>
<td><p>CNF formulas augmented with <em>native</em> cardinality constraints.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">WCNF</span></code></p></td>
<td><p>Class for manipulating partial (weighted) CNF formulas.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">WCNFPlus</span></code></p></td>
<td><p>WCNF formulas augmented with <em>native</em> cardinality constraints.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">¶</a></h2>
<p>This module is designed to facilitate fast and easy PySAT-development by
providing a simple way to manipulate formulas in PySAT. Although only
clausal formulas are supported at this point, future releases of PySAT are
expected to implement data structures and methods to manipulate arbitrary
Boolean formulas. The module implements the <code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code> class, which
represents a formula in <a class="reference external" href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive normal form (CNF)</a>.</p>
<p>Recall that a CNF formula is conventionally seen as a set of clauses, each
being a set of literals. A literal is a Boolean variable or its negation.
In PySAT, a Boolean variable and a literal should be specified as an
integer. For instance, a Boolean variable <span class="math notranslate nohighlight">\(x_{25}\)</span> is represented as
integer <code class="docutils literal notranslate"><span class="pre">25</span></code>. A literal <span class="math notranslate nohighlight">\(\neg{x_{10}}\)</span> should be specified as
<code class="docutils literal notranslate"><span class="pre">-10</span></code>. Moreover, a clause <span class="math notranslate nohighlight">\((\neg{x_2}\vee x_{19}\vee x_{46})\)</span>
should be specified as <code class="docutils literal notranslate"><span class="pre">[-2,</span> <span class="pre">19,</span> <span class="pre">46]</span></code> in PySAT. <em>Unit size clauses</em> are
to be specified as unit size lists as well, e.g. a clause <span class="math notranslate nohighlight">\((x_3)\)</span> is
a list <code class="docutils literal notranslate"><span class="pre">[3]</span></code>.</p>
<p>CNF formulas can be created as an object of class <code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code>. For
instance, the following piece of code creates a CNF formula
<span class="math notranslate nohighlight">\((\neg{x_1}\vee x_2)\wedge(\neg{x_2}\vee x_3)\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>The clauses of a formula can be accessed through the <code class="docutils literal notranslate"><span class="pre">clauses</span></code> variable
of class <code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code>, which is a list of lists of integers:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2 ,3]]</span>
</pre></div>
</div>
<p>The number of variables in a CNF formula, i.e. the <em>largest variable
identifier</em>, can be obtained using the <code class="docutils literal notranslate"><span class="pre">nv</span></code> variable, e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Class <code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code> has a few methods to read and write a CNF formula into a
file or a string. The formula is read/written in the standard <a class="reference external" href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#SAT_problem_format">DIMACS CNF</a>
format. A clause in the DIMACS format is a string containing
space-separated integer literals  followed by <code class="docutils literal notranslate"><span class="pre">0</span></code>. For instance, a clause
<span class="math notranslate nohighlight">\((\neg{x_2}\vee x_{19}\vee x_{46})\)</span> is written as <code class="docutils literal notranslate"><span class="pre">-2</span> <span class="pre">19</span> <span class="pre">46</span> <span class="pre">0</span></code>
in DIMACS. The clauses in DIMACS should be preceded by a <em>preamble</em>, which
is a line <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">cnf</span> <span class="pre">nof_variables</span> <span class="pre">nof_clauses</span></code>, where <code class="docutils literal notranslate"><span class="pre">nof_variables</span></code> and
<code class="docutils literal notranslate"><span class="pre">nof_clauses</span></code> are integers. A preamble line for formula
<span class="math notranslate nohighlight">\((\neg{x_1}\vee x_2)\wedge(\neg{x_2}\vee x_3)\)</span> would be <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">cnf</span>
<span class="pre">3</span> <span class="pre">2</span></code>. The complete DIMACS file describing the formula looks this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="n">cnf</span> <span class="mi">3</span> <span class="mi">2</span>
<span class="o">-</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Reading and writing formulas in DIMACS can be done with PySAT in the
following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># reading from file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;another-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># reading from a file pointer</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">f2</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to a file pointer</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf 3 3</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">-2 3 0</span><span class="se">\n</span><span class="s1">-3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f3</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2, 3], [-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f3</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Besides plain CNF formulas, the <a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a> module implements an
additional class for dealing with <em>partial</em> and <em>weighted partial</em> CNF
formulas, i.e. WCNF formulas. A WCNF formula is a conjunction of two sets
of clauses: <em>hard</em> clauses and <em>soft</em> clauses, i.e.
<span class="math notranslate nohighlight">\(\mathcal{F}=\mathcal{H}\wedge\mathcal{S}\)</span>. Soft clauses of a WCNF
are labeled with integer <em>weights</em>, i.e. a soft clause of
<span class="math notranslate nohighlight">\(\mathcal{S}\)</span> is a pair <span class="math notranslate nohighlight">\((c_i, w_i)\)</span>. In partial (unweighted)
formulas, all soft clauses have weight 1.</p>
<p>WCNF can be of help when solving optimization problems using the SAT
technology. A typical example of where a WCNF formula can be used is
<a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_satisfiability_problem">maximum satisfiability (MaxSAT)</a>, which
given a WCNF formula <span class="math notranslate nohighlight">\(\mathcal{F}=\mathcal{H}\wedge\mathcal{S}\)</span>
targets satisfying all its hard clauses <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> and maximizing
the sum of weights of satisfied soft clauses, i.e. maximizing the value of
<span class="math notranslate nohighlight">\(\sum_{c_i\in\mathcal{S}}{w_i\cdot c_i}\)</span>.</p>
<p>An object of class <code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code> has two variables to access the hard and
soft clauses of the corresponding formula: <code class="docutils literal notranslate"><span class="pre">hard</span></code> and <code class="docutils literal notranslate"><span class="pre">soft</span></code>. The
weights of soft clauses are stored in variable <code class="docutils literal notranslate"><span class="pre">wght</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># the formula becomes unsatisfiable</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, -2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1], [2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
<p>A properly constructed WCNF formula must have a <em>top weight</em>, which should
be equal to <span class="math notranslate nohighlight">\(1+\sum_{c_i\in\mathcal{S}}{w_i}\)</span>. Top weight of a
formula can be accessed through variable <code class="docutils literal notranslate"><span class="pre">topw</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">topw</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># (1 + 3) + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">topw</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although it is not aligned with the WCNF format description, starting
with the 0.1.5.dev8 release, PySAT is able to deal with WCNF formulas
having not only integer clause weights but also weights represented as
<em>floating point numbers</em>. Moreover, <em>negative weights</em> are also
supported.</p>
</div>
<p>Additionally to classes <code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code>, the module provides
the extended classes <code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code>. The only
difference between <code class="docutils literal notranslate"><span class="pre">?CNF</span></code> and <code class="docutils literal notranslate"><span class="pre">?CNFPlus</span></code> is the support for <em>native</em>
cardinality constraints provided by the <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard solver</a> (see <a class="reference internal" href="card.html#module-pysat.card" title="pysat.card"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code></a> for
details). The corresponding variable in objects of <code class="docutils literal notranslate"><span class="pre">CNFPlus</span></code>
(<code class="docutils literal notranslate"><span class="pre">WCNFPlus</span></code>, resp.) responsible for storing the AtMostK constraints is
<code class="docutils literal notranslate"><span class="pre">atmosts</span></code> (<code class="docutils literal notranslate"><span class="pre">atms</span></code>, resp.). <strong>Note</strong> that at this point, AtMostK
constraints in <code class="docutils literal notranslate"><span class="pre">WCNF</span></code> can be <em>hard</em> only.</p>
<p>Besides the implementations of CNF and WCNF formulas in PySAT, the
<a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a> module also provides a way to manage variable
identifiers. This can be done with the use of the <code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code> manager.
With the use of the <code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code> classes as well as with
the <code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code> variable manager, it is pretty easy to develop
practical problem encoders into SAT or MaxSAT/MinSAT. As an example, a PHP
formula encoder is shown below (the implementation can also be found in
<code class="xref py py-class docutils literal notranslate"><span class="pre">examples.genhard.PHP</span></code>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>  <span class="c1"># we will store the formula here</span>

<span class="c1"># nof_holes is given</span>

<span class="c1"># initializing the pool of variable ids</span>
<span class="n">vpool</span> <span class="o">=</span> <span class="n">IDPool</span><span class="p">(</span><span class="n">start_from</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pigeon</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;pigeon</span><span class="si">{0}</span><span class="s1">@</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

<span class="c1"># placing all pigeons into holes</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pigeon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

<span class="c1"># there cannot be more than 1 pigeon in a hole</span>
<span class="n">pigeons</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">pigeons</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="n">pigeon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/pysat.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pysathq&repo=pysat&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div class="sidebarblock">
    <div class="tile">
    <h4>Latest version:</h4>
    0.1.5.dev12 (<a href="https://github.com/pysathq/pysat">GitHub</a>)
    </div>
    </br>
</div>
<div class="sidebarblock">
    <div class="tile">
    <h4><a href="https://pysathq.github.io">Main webpage</a></h4>
    </div>
</div>
</br>
<div class="sidebarblock">
<h4>Contact us:</h4>
      <a class="reference external" href="https://github.com/pysathq/pysat/issues">
            Issue tracker
      </a>
      |
      <a class="reference external" href="mailto:pysathq@gmail.com">
          Email
      </a>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2020, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/api/formula.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>