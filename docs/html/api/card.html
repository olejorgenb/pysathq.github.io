
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Cardinality encodings (pysat.card) &#8212; PySAT 0.1.5.dev6 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Boolean formula manipulation (pysat.formula)" href="formula.html" />
    <link rel="prev" title="Welcome to PySAT’s documentation!" href="../index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-pysat.card">
<span id="cardinality-encodings-pysat-card"></span><h1>Cardinality encodings (<a class="reference internal" href="#module-pysat.card" title="pysat.card"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code></a>)<a class="headerlink" href="#module-pysat.card" title="Permalink to this headline">¶</a></h1>
<div class="section" id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.card.EncType" title="pysat.card.EncType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EncType</span></code></a></p></td>
<td><p>This class represents a C-like <code class="docutils literal notranslate"><span class="pre">enum</span></code> type for choosing the cardinality encoding to use.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.card.CardEnc" title="pysat.card.CardEnc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CardEnc</span></code></a></p></td>
<td><p>This abstract class is responsible for the creation of cardinality constraints encoded to a CNF formula.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ITotalizer</span></code></a></p></td>
<td><p>This class implements the iterative totalizer encoding <a class="footnote-reference brackets" href="#id24" id="id1">11</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">¶</a></h2>
<p>This module provides access to various <em>cardinality constraint</em> <a class="footnote-reference brackets" href="#id13" id="id2">1</a>
encodings to formulas in conjunctive normal form (CNF). These include
pairwise <a class="footnote-reference brackets" href="#id14" id="id3">2</a>, bitwise <a class="footnote-reference brackets" href="#id14" id="id4">2</a>, ladder/regular <a class="footnote-reference brackets" href="#id15" id="id5">3</a> <a class="footnote-reference brackets" href="#id16" id="id6">4</a>, sequential counters
<a class="footnote-reference brackets" href="#id17" id="id7">5</a>, sorting <a class="footnote-reference brackets" href="#id18" id="id8">6</a> and cardinality networks <a class="footnote-reference brackets" href="#id19" id="id9">7</a>, totalizer <a class="footnote-reference brackets" href="#id20" id="id10">8</a>, modulo
totalizer <a class="footnote-reference brackets" href="#id21" id="id11">9</a>, and modulo totalizer for <span class="math notranslate nohighlight">\(k\)</span>-cardinality <a class="footnote-reference brackets" href="#id22" id="id12">10</a>, as
well as a <em>native</em> cardinality constraint representation supported by the
<a class="reference external" href="https://github.com/liffiton/minicard">MiniCard solver</a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Olivier Roussel, Vasco M. Manquinho. <em>Pseudo-Boolean and Cardinality
Constraints</em>. Handbook of Satisfiability.  2009. pp. 695-733</p>
</dd>
<dt class="label" id="id14"><span class="brackets">2</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id4">2</a>)</span></dt>
<dd><p>Steven David Prestwich. <em>CNF Encodings</em>. Handbook of Satisfiability.
2009. pp. 75-97</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>Carlos Ansótegui, Felip Manyà. <em>Mapping Problems with Finite-Domain
Variables to Problems with Boolean Variables</em>. SAT (Selected Papers)
2004. pp. 1-15</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>Ian P. Gent, Peter Nightingale. <em>A New Encoding of Alldifferent Into
SAT</em>. In International workshop on modelling and reformulating
constraint satisfaction problems 2004. pp. 95-110</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id7">5</a></span></dt>
<dd><p>Carsten Sinz. <em>Towards an Optimal CNF Encoding of Boolean
Cardinality Constraints</em>. CP 2005. pp. 827-831</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id8">6</a></span></dt>
<dd><p>Kenneth E. Batcher. <em>Sorting Networks and Their Applications</em>.
AFIPS Spring Joint Computing Conference 1968. pp. 307-314</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id9">7</a></span></dt>
<dd><p>Roberto Asin, Robert Nieuwenhuis, Albert Oliveras,
Enric Rodriguez-Carbonell. <em>Cardinality Networks and Their
Applications</em>. SAT 2009. pp. 167-180</p>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id10">8</a></span></dt>
<dd><p>Olivier Bailleux, Yacine Boufkhad. <em>Efficient CNF Encoding of
Boolean Cardinality Constraints</em>. CP 2003. pp. 108-122</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id11">9</a></span></dt>
<dd><p>Toru Ogawa, Yangyang Liu, Ryuzo Hasegawa, Miyuki Koshimura,
Hiroshi Fujita. <em>Modulo Based CNF Encoding of Cardinality Constraints
and Its Application to MaxSAT Solvers</em>. ICTAI 2013. pp. 9-17</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id12">10</a></span></dt>
<dd><p>António Morgado, Alexey Ignatiev, Joao Marques-Silva. <em>MSCG: Robust
Core-Guided MaxSAT Solving</em>. System Description. JSAT 2015. vol. 9,
pp. 129-134</p>
</dd>
</dl>
<p>A cardinality constraint is a constraint of the form:
<span class="math notranslate nohighlight">\(\sum_{i=1}^n{x_i}\leq k\)</span>. Cardinality constraints are ubiquitous in
practical problem formulations. Note that the implementation of the
pairwise, bitwise, and ladder encodings can only deal with AtMost1
constraints, e.g. <span class="math notranslate nohighlight">\(\sum_{i=1}^n{x_i}\leq 1\)</span>.</p>
<p>Access to all cardinality encodings can be made through the main class of
this module, which is <a class="reference internal" href="#pysat.card.CardEnc" title="pysat.card.CardEnc"><code class="xref py py-class docutils literal notranslate"><span class="pre">CardEnc</span></code></a>.</p>
<p>Additionally, to the standard cardinality encodings that are basically
“static” CNF formulas, the module is designed to able to construct
<em>incremental</em> cardinality encodings, i.e. those that can be incrementally
extended at a later stage. At this point only the <em>iterative totalizer</em>
<a class="footnote-reference brackets" href="#id24" id="id23">11</a> encoding is supported. Iterative totalizer can be accessed with the
use of the <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> class.</p>
<dl class="footnote brackets">
<dt class="label" id="id24"><span class="brackets">11</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id23">2</a>,<a href="#id25">3</a>)</span></dt>
<dd><p>Ruben Martins, Saurabh Joshi, Vasco M. Manquinho, Inês Lynce.
<em>Incremental Cardinality Constraints for MaxSAT</em>. CP 2014. pp. 531-548</p>
</dd>
</dl>
</div>
<div class="section" id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pysat.card.CardEnc">
<em class="property">class </em><code class="sig-prename descclassname">pysat.card.</code><code class="sig-name descname">CardEnc</code><a class="headerlink" href="#pysat.card.CardEnc" title="Permalink to this definition">¶</a></dt>
<dd><p>This abstract class is responsible for the creation of cardinality
constraints encoded to a CNF formula. The class has three <em>class
methods</em> for creating AtMostK, AtLeastK, and EqualsK constraints. Given
a list of literals, an integer bound and an encoding type, each of
these methods returns an object of class <a class="reference internal" href="formula.html#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">pysat.formula.CNFPlus</span></code></a>
representing the resulting CNF formula.</p>
<p>Since the class is abstract, there is no need to create an object of
it. Instead, the methods should be called directly as class methods,
e.g. <code class="docutils literal notranslate"><span class="pre">CardEnc.atmost(lits,</span> <span class="pre">bound)</span></code> or <code class="docutils literal notranslate"><span class="pre">CardEnc.equals(lits,</span>
<span class="pre">bound)</span></code>. An example usage is the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CardEnc</span><span class="o">.</span><span class="n">atmost</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">encoding</span><span class="o">=</span><span class="n">EncType</span><span class="o">.</span><span class="n">pairwise</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, -2], [-1, -3], [-2, -3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CardEnc</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">encoding</span><span class="o">=</span><span class="n">EncType</span><span class="o">.</span><span class="n">pairwise</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[1, 2, 3], [-1, -2], [-1, -3], [-2, -3]]</span>
</pre></div>
</div>
<dl class="method">
<dt id="pysat.card.CardEnc.atleast">
<em class="property">classmethod </em><code class="sig-name descname">atleast</code><span class="sig-paren">(</span><em class="sig-param">lits</em>, <em class="sig-param">bound=1</em>, <em class="sig-param">top_id=None</em>, <em class="sig-param">vpool=None</em>, <em class="sig-param">encoding=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.CardEnc.atleast" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be used for creating a CNF encoding of an AtLeastK
constraint, i.e. of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\geq k\)</span>. The method
takes 1 mandatory argument <code class="docutils literal notranslate"><span class="pre">lits</span></code> and 3 default arguments can be
specified: <code class="docutils literal notranslate"><span class="pre">bound</span></code>, <code class="docutils literal notranslate"><span class="pre">top_id</span></code>, <code class="docutils literal notranslate"><span class="pre">vpool</span></code>, and <code class="docutils literal notranslate"><span class="pre">encoding</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lits</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of literals in the sum.</p></li>
<li><p><strong>bound</strong> (<em>int</em>) – the value of bound <span class="math notranslate nohighlight">\(k\)</span>.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – top variable identifier used so far.</p></li>
<li><p><strong>vpool</strong> (<a class="reference internal" href="formula.html#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a>) – variable pool for counting the number of variables.</p></li>
<li><p><strong>encoding</strong> (<em>integer</em>) – identifier of the encoding to use.</p></li>
</ul>
</dd>
</dl>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">top_id</span></code> serves to increase integer identifiers of
auxiliary variables introduced during the encoding process. This
is helpful when augmenting an existing CNF formula with the new
cardinality encoding to make sure there is no collision between
identifiers of the variables. If specified, the identifiers of the
first auxiliary variable will be <code class="docutils literal notranslate"><span class="pre">top_id+1</span></code>.</p>
<p>Instead of <code class="docutils literal notranslate"><span class="pre">top_id</span></code>, one may want to use a pool of variable
identifiers <code class="docutils literal notranslate"><span class="pre">vpool</span></code>, which is automatically updated during the
method call. In many circumstances, this is more convenient than
using <code class="docutils literal notranslate"><span class="pre">top_id</span></code>. Also note that parameters <code class="docutils literal notranslate"><span class="pre">top_id</span></code> and
<code class="docutils literal notranslate"><span class="pre">vpool</span></code> <strong>cannot</strong> be specified <em>simultaneusly</em>.</p>
<p>The default value of <code class="docutils literal notranslate"><span class="pre">encoding</span></code> is <code class="xref py py-attr docutils literal notranslate"><span class="pre">Enctype.seqcounter</span></code>.</p>
<p>The method <em>translates</em> the AtLeast constraint into an AtMost
constraint by <em>negating</em> the literals of <code class="docutils literal notranslate"><span class="pre">lits</span></code>, creating a new
bound <span class="math notranslate nohighlight">\(n-k\)</span> and invoking <a class="reference internal" href="#pysat.card.CardEnc.atmost" title="pysat.card.CardEnc.atmost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atmost()</span></code></a> with the
modified list of literals and the new bound.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>CardEnc.NoSuchEncodingError</strong> – if encoding does not exist.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>a <a class="reference internal" href="formula.html#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> object where the new             clauses (or the new native atmost constraint) are stored.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pysat.card.CardEnc.atmost">
<em class="property">classmethod </em><code class="sig-name descname">atmost</code><span class="sig-paren">(</span><em class="sig-param">lits</em>, <em class="sig-param">bound=1</em>, <em class="sig-param">top_id=None</em>, <em class="sig-param">vpool=None</em>, <em class="sig-param">encoding=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.CardEnc.atmost" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be used for creating a CNF encoding of an AtMostK
constraint, i.e. of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\leq k\)</span>. The method
shares the arguments and the return type with method
<a class="reference internal" href="#pysat.card.CardEnc.atleast" title="pysat.card.CardEnc.atleast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atleast()</span></code></a>. Please, see it for details.</p>
</dd></dl>

<dl class="method">
<dt id="pysat.card.CardEnc.equals">
<em class="property">classmethod </em><code class="sig-name descname">equals</code><span class="sig-paren">(</span><em class="sig-param">lits</em>, <em class="sig-param">bound=1</em>, <em class="sig-param">top_id=None</em>, <em class="sig-param">vpool=None</em>, <em class="sig-param">encoding=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.CardEnc.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be used for creating a CNF encoding of an EqualsK
constraint, i.e. of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}= k\)</span>. The method
makes consecutive calls of both <a class="reference internal" href="#pysat.card.CardEnc.atleast" title="pysat.card.CardEnc.atleast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atleast()</span></code></a> and
<a class="reference internal" href="#pysat.card.CardEnc.atmost" title="pysat.card.CardEnc.atmost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atmost()</span></code></a>. It shares the arguments and the return type
with method <a class="reference internal" href="#pysat.card.CardEnc.atleast" title="pysat.card.CardEnc.atleast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atleast()</span></code></a>. Please, see it for details.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysat.card.EncType">
<em class="property">class </em><code class="sig-prename descclassname">pysat.card.</code><code class="sig-name descname">EncType</code><a class="headerlink" href="#pysat.card.EncType" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a C-like <code class="docutils literal notranslate"><span class="pre">enum</span></code> type for choosing the
cardinality encoding to use. The values denoting the encodings are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pairwise</span>    <span class="o">=</span> <span class="mi">0</span>
<span class="n">seqcounter</span>  <span class="o">=</span> <span class="mi">1</span>
<span class="n">sortnetwrk</span>  <span class="o">=</span> <span class="mi">2</span>
<span class="n">cardnetwrk</span>  <span class="o">=</span> <span class="mi">3</span>
<span class="n">bitwise</span>     <span class="o">=</span> <span class="mi">4</span>
<span class="n">ladder</span>      <span class="o">=</span> <span class="mi">5</span>
<span class="n">totalizer</span>   <span class="o">=</span> <span class="mi">6</span>
<span class="n">mtotalizer</span>  <span class="o">=</span> <span class="mi">7</span>
<span class="n">kmtotalizer</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">native</span>      <span class="o">=</span> <span class="mi">9</span>
</pre></div>
</div>
<p>The desired encoding can be selected either directly by its integer
identifier, e.g. <code class="docutils literal notranslate"><span class="pre">2</span></code>, or by its alphabetical name, e.g.
<code class="docutils literal notranslate"><span class="pre">EncType.sortnetwrk</span></code>.</p>
<p>Note that while most of the encodings are produced as a list of
clauses, the “native” encoding of <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard</a> is managed as one clause.
Given an AtMostK constraint <span class="math notranslate nohighlight">\(\sum_{i=1}^n{x_i\leq k}\)</span>, the native
encoding represents it as a pair <code class="docutils literal notranslate"><span class="pre">[lits,</span> <span class="pre">k]</span></code>, where <code class="docutils literal notranslate"><span class="pre">lits</span></code> is a
list of size <code class="docutils literal notranslate"><span class="pre">n</span></code> containing literals in the sum.</p>
</dd></dl>

<dl class="class">
<dt id="pysat.card.ITotalizer">
<em class="property">class </em><code class="sig-prename descclassname">pysat.card.</code><code class="sig-name descname">ITotalizer</code><span class="sig-paren">(</span><em class="sig-param">lits=[]</em>, <em class="sig-param">ubound=1</em>, <em class="sig-param">top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer" title="Permalink to this definition">¶</a></dt>
<dd><p>This class implements the iterative totalizer encoding <a class="footnote-reference brackets" href="#id24" id="id25">11</a>. Note that
<a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> can be used only for creating AtMostK constraints.
In contrast to class <a class="reference internal" href="#pysat.card.EncType" title="pysat.card.EncType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EncType</span></code></a>, this class is not abstract and
its objects once created can be reused several times. The idea is that
a <em>totalizer tree</em> can be extended, or the bound can be increased, as
well as two totalizer trees can be merged into one.</p>
<p>The constructor of the class object takes 3 default arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lits</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of literals to sum.</p></li>
<li><p><strong>ubound</strong> (<em>int</em>) – the largest potential bound to use.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – top variable identifier used so far.</p></li>
</ul>
</dd>
</dl>
<p>The encoding of the current tree can be accessed with the use of
<a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> variable stored as <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. Potential bounds <strong>are
not</strong> imposed by default but can be added as unit clauses in the final
CNF formula. The bounds are stored in the list of Boolean variables as
<code class="docutils literal notranslate"><span class="pre">self.rhs</span></code>. A concrete bound <span class="math notranslate nohighlight">\(k\)</span> can be enforced by considering
a unit clause <code class="docutils literal notranslate"><span class="pre">-self.rhs[k]</span></code>. <strong>Note</strong> that <code class="docutils literal notranslate"><span class="pre">-self.rhs[0]</span></code> enforces
all literals of the sum to be <em>false</em>.</p>
<p>An <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object should be deleted if it is not needed
anymore.</p>
<p>Possible usage of the class is shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively, an object can be created using the <code class="docutils literal notranslate"><span class="pre">with</span></code> keyword. In
this case, the object is deleted automatically:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7]]</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7]</span>
</pre></div>
</div>
<dl class="method">
<dt id="pysat.card.ITotalizer.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroys a previously constructed <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object.
Internal variables <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code> and <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code> get cleaned.</p>
</dd></dl>

<dl class="method">
<dt id="pysat.card.ITotalizer.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">lits=[]</em>, <em class="sig-param">ubound=None</em>, <em class="sig-param">top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends the list of literals in the sum and (if needed) increases a
potential upper bound that can be imposed on the complete list of
literals in the sum of an existing <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object to a
new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lits</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – additional literals to be included in the sum.</p></li>
<li><p><strong>ubound</strong> (<em>int</em>) – a new upper bound.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – a new top variable identifier.</p></li>
</ul>
</dd>
</dl>
<p>The top identifier <code class="docutils literal notranslate"><span class="pre">top_id</span></code> applied only if it is greater than
the one used in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method creates additional clauses encoding the existing
totalizer tree augmented with new literals in the sum and updating
the upper bound. As a result, it appends the new clauses to the
list of clauses of <a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. The number of newly
created clauses is stored in variable <code class="docutils literal notranslate"><span class="pre">self.nof_new</span></code>.</p>
<p>Also, if the upper bound is updated, a list of bounds <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code>
gets increased and its length becomes <code class="docutils literal notranslate"><span class="pre">ubound+1</span></code>. Otherwise, it
is updated with new values.</p>
<p>The method can be used in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[3, 4]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4], [-5, 6], [-3, 6], [-4, 7], [-3, -5, 7], [-4, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">nof_new</span><span class="p">:])</span>
<span class="go">[[-5, 6], [-3, 6], [-4, 7], [-3, -5, 7], [-4, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.card.ITotalizer.increase">
<code class="sig-name descname">increase</code><span class="sig-paren">(</span><em class="sig-param">ubound=1</em>, <em class="sig-param">top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.increase" title="Permalink to this definition">¶</a></dt>
<dd><p>Increases a potential upper bound that can be imposed on the
literals in the sum of an existing <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object to a
new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ubound</strong> (<em>int</em>) – a new upper bound.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – a new top variable identifier.</p></li>
</ul>
</dd>
</dl>
<p>The top identifier <code class="docutils literal notranslate"><span class="pre">top_id</span></code> applied only if it is greater than
the one used in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method creates additional clauses encoding the existing
totalizer tree up to the new upper bound given and appends them to
the list of clauses of <a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. The number of
newly created clauses is stored in variable <code class="docutils literal notranslate"><span class="pre">self.nof_new</span></code>.</p>
<p>Also, a list of bounds <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code> gets increased and its length
becomes <code class="docutils literal notranslate"><span class="pre">ubound+1</span></code>.</p>
<p>The method can be used in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">increase</span><span class="p">(</span><span class="n">ubound</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7], [-3, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">nof_new</span><span class="p">:])</span>
<span class="go">[[-3, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.card.ITotalizer.merge_with">
<code class="sig-name descname">merge_with</code><span class="sig-paren">(</span><em class="sig-param">another</em>, <em class="sig-param">ubound=None</em>, <em class="sig-param">top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.merge_with" title="Permalink to this definition">¶</a></dt>
<dd><p>This method merges a tree of the current <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a>
object, with a tree of another object and (if needed) increases a
potential upper bound that can be imposed on the complete list of
literals in the sum of an existing <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object to a
new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>another</strong> (<a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a>) – another totalizer to merge with.</p></li>
<li><p><strong>ubound</strong> (<em>int</em>) – a new upper bound.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – a new top variable identifier.</p></li>
</ul>
</dd>
</dl>
<p>The top identifier <code class="docutils literal notranslate"><span class="pre">top_id</span></code> applied only if it is greater than
the one used in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method creates additional clauses encoding the existing
totalizer tree merged with another totalizer tree into <em>one</em> sum
and updating the upper bound. As a result, it appends the new
clauses to the list of clauses of <a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. The
number of newly created clauses is stored in variable
<code class="docutils literal notranslate"><span class="pre">self.nof_new</span></code>.</p>
<p>Also, if the upper bound is updated, a list of bounds <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code>
gets increased and its length becomes <code class="docutils literal notranslate"><span class="pre">ubound+1</span></code>. Otherwise, it
is updated with new values.</p>
<p>The method can be used in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">t1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4]]</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[3, 4]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">t2</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-6, 7], [-5, 7], [-5, -6, 8]]</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[7, 8]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">t1</span><span class="o">.</span><span class="n">merge_with</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4], [-6, 7], [-5, 7], [-5, -6, 8], [-7, 9], [-8, 10], [-3, 9], [-4, 10], [-3, -7, 10]]</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="o">-</span><span class="n">t1</span><span class="o">.</span><span class="n">nof_new</span><span class="p">:])</span>
<span class="go">[[-6, 7], [-5, 7], [-5, -6, 8], [-7, 9], [-8, 10], [-3, 9], [-4, 10], [-3, -7, 10]]</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[9, 10]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">t2</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.card.ITotalizer.new">
<code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param">lits=[]</em>, <em class="sig-param">ubound=1</em>, <em class="sig-param">top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.new" title="Permalink to this definition">¶</a></dt>
<dd><p>The actual constructor of <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a>. Invoked from
<code class="docutils literal notranslate"><span class="pre">self.__init__()</span></code>. Creates an object of <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> given
a list of literals in the sum, the largest potential bound to
consider, as well as the top variable identifier used so far. See
the description of <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> for details.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pysat.card.NoSuchEncodingError">
<em class="property">exception </em><code class="sig-prename descclassname">pysat.card.</code><code class="sig-name descname">NoSuchEncodingError</code><a class="headerlink" href="#pysat.card.NoSuchEncodingError" title="Permalink to this definition">¶</a></dt>
<dd><p>This exception is raised when creating an unknown an AtMostk, AtLeastK,
or EqualK constraint encoding.</p>
<dl class="method">
<dt id="pysat.card.NoSuchEncodingError.with_traceback">
<code class="sig-name descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.NoSuchEncodingError.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/pysat.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pysathq&repo=pysat&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div class="sidebarblock">
    <div class="tile">
    <h4>Latest version:</h4>
    0.1.5.dev6 (<a href="https://github.com/pysathq/pysat">GitHub</a>)
    </div>
    </br>
</div>
<div class="sidebarblock">
    <div class="tile">
    <h4><a href="https://pysathq.github.io">Main webpage</a></h4>
    </div>
</div>
</br>
<div class="sidebarblock">
<h4>Contact us:</h4>
      <a class="reference external" href="https://github.com/pysathq/pysat/issues">
            Issue tracker
      </a>
      |
      <a class="reference external" href="mailto:pysathq@gmail.com">
          Email
      </a>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2020, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/api/card.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>