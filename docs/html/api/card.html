
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Cardinality encodings (pysat.card) &#8212; PySAT 0.1.3.dev11 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Boolean formula manipulation (pysat.formula)" href="formula.html" />
    <link rel="prev" title="Welcome to PySAT’s documentation!" href="../index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-pysat.card">
<span id="cardinality-encodings-pysat-card"></span><h1>Cardinality encodings (<a class="reference internal" href="#module-pysat.card" title="pysat.card"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code></a>)<a class="headerlink" href="#module-pysat.card" title="Permalink to this headline">¶</a></h1>
<div class="section" id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pysat.card.EncType" title="pysat.card.EncType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EncType</span></code></a></td>
<td>This class represents a C-like <code class="docutils literal notranslate"><span class="pre">enum</span></code> type for choosing the cardinality encoding to use.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pysat.card.CardEnc" title="pysat.card.CardEnc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CardEnc</span></code></a></td>
<td>This abstract class is responsible for the creation of cardinality constraints encoded to a CNF formula.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ITotalizer</span></code></a></td>
<td>This class implements the iterative totalizer encoding <a class="footnote-reference" href="#id24" id="id1">[11]</a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">¶</a></h2>
<p>This module provides access to various <em>cardinality constraint</em> <a class="footnote-reference" href="#id13" id="id2">[1]</a>
encodings to formulas in conjunctive normal form (CNF). These include
pairwise <a class="footnote-reference" href="#id14" id="id3">[2]</a>, bitwise <a class="footnote-reference" href="#id14" id="id4">[2]</a>, ladder/regular <a class="footnote-reference" href="#id15" id="id5">[3]</a> <a class="footnote-reference" href="#id16" id="id6">[4]</a>, sequential counters
<a class="footnote-reference" href="#id17" id="id7">[5]</a>, sorting <a class="footnote-reference" href="#id18" id="id8">[6]</a> and cardinality networks <a class="footnote-reference" href="#id19" id="id9">[7]</a>, totalizer <a class="footnote-reference" href="#id20" id="id10">[8]</a>, modulo
totalizer <a class="footnote-reference" href="#id21" id="id11">[9]</a>, and modulo totalizer for <span class="math notranslate nohighlight">\(k\)</span>-cardinality <a class="footnote-reference" href="#id22" id="id12">[10]</a>, as
well as a <em>native</em> cardinality constraint representation supported by the
<a class="reference external" href="https://github.com/liffiton/minicard">MiniCard solver</a>.</p>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Olivier Roussel, Vasco M. Manquinho. <em>Pseudo-Boolean and Cardinality
Constraints</em>. Handbook of Satisfiability.  2009. pp. 695-733</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Steven David Prestwich. <em>CNF Encodings</em>. Handbook of Satisfiability.
2009. pp. 75-97</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>Carlos Ansótegui, Felip Manyà. <em>Mapping Problems with Finite-Domain
Variables to Problems with Boolean Variables</em>. SAT (Selected Papers)
2004. pp. 1-15</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>Ian P. Gent, Peter Nightingale. <em>A New Encoding of Alldifferent Into
SAT</em>. In International workshop on modelling and reformulating
constraint satisfaction problems 2004. pp. 95-110</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[5]</a></td><td>Carsten Sinz. <em>Towards an Optimal CNF Encoding of Boolean
Cardinality Constraints</em>. CP 2005. pp. 827-831</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[6]</a></td><td>Kenneth E. Batcher. <em>Sorting Networks and Their Applications</em>.
AFIPS Spring Joint Computing Conference 1968. pp. 307-314</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[7]</a></td><td>Roberto Asin, Robert Nieuwenhuis, Albert Oliveras,
Enric Rodriguez-Carbonell. <em>Cardinality Networks and Their
Applications</em>. SAT 2009. pp. 167-180</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[8]</a></td><td>Olivier Bailleux, Yacine Boufkhad. <em>Efficient CNF Encoding of
Boolean Cardinality Constraints</em>. CP 2003. pp. 108-122</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[9]</a></td><td>Toru Ogawa, Yangyang Liu, Ryuzo Hasegawa, Miyuki Koshimura,
Hiroshi Fujita. <em>Modulo Based CNF Encoding of Cardinality Constraints
and Its Application to MaxSAT Solvers</em>. ICTAI 2013. pp. 9-17</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[10]</a></td><td>António Morgado, Alexey Ignatiev, Joao Marques-Silva. <em>MSCG: Robust
Core-Guided MaxSAT Solving</em>. System Description. JSAT 2015. vol. 9,
pp. 129-134</td></tr>
</tbody>
</table>
<p>A cardinality constraint is a constraint of the form:
<span class="math notranslate nohighlight">\(\sum_{i=1}^n{x_i}\leq k\)</span>. Cardinality constraints are ubiquitous in
practical problem formulations. Note that the implementation of the
pairwise, bitwise, and ladder encodings can only deal with AtMost1
constraints, e.g. <span class="math notranslate nohighlight">\(\sum_{i=1}^n{x_i}\leq 1\)</span>.</p>
<p>Access to all cardinality encodings can be made through the main class of
this module, which is <a class="reference internal" href="#pysat.card.CardEnc" title="pysat.card.CardEnc"><code class="xref py py-class docutils literal notranslate"><span class="pre">CardEnc</span></code></a>.</p>
<p>Additionally, to the standard cardinality encodings that are basically
“static” CNF formulas, the module is designed to able to construct
<em>incremental</em> cardinality encodings, i.e. those that can be incrementally
extended at a later stage. At this point only the <em>iterative totalizer</em>
<a class="footnote-reference" href="#id24" id="id23">[11]</a> encoding is supported. Iterative totalizer can be accessed with the
use of the <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> class.</p>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id23">2</a>, <a class="fn-backref" href="#id25">3</a>)</em> Ruben Martins, Saurabh Joshi, Vasco M. Manquinho, Inês Lynce.
<em>Incremental Cardinality Constraints for MaxSAT</em>. CP 2014. pp. 531-548</td></tr>
</tbody>
</table>
</div>
<div class="section" id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pysat.card.CardEnc">
<em class="property">class </em><code class="descclassname">pysat.card.</code><code class="descname">CardEnc</code><a class="headerlink" href="#pysat.card.CardEnc" title="Permalink to this definition">¶</a></dt>
<dd><p>This abstract class is responsible for the creation of cardinality
constraints encoded to a CNF formula. The class has three <em>class
methods</em> for creating AtMostK, AtLeastK, and EqualsK constraints. Given
a list of literals, an integer bound and an encoding type, each of
these methods returns an object of class <a class="reference internal" href="formula.html#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">pysat.formula.CNFPlus</span></code></a>
representing the resulting CNF formula.</p>
<p>Since the class is abstract, there is no need to create an object of
it. Instead, the methods should be called directly as class methods,
e.g. <code class="docutils literal notranslate"><span class="pre">CardEnc.atmost(lits,</span> <span class="pre">bound)</span></code> or <code class="docutils literal notranslate"><span class="pre">CardEnc.equals(lits,</span>
<span class="pre">bound)</span></code>. An example usage is the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CardEnc</span><span class="o">.</span><span class="n">atmost</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">encoding</span><span class="o">=</span><span class="n">EncType</span><span class="o">.</span><span class="n">pairwise</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-1, -2], [-1, -3], [-2, -3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CardEnc</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">encoding</span><span class="o">=</span><span class="n">EncType</span><span class="o">.</span><span class="n">pairwise</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[1, 2, 3], [-1, -2], [-1, -3], [-2, -3]]</span>
</pre></div>
</div>
<dl class="classmethod">
<dt id="pysat.card.CardEnc.atleast">
<em class="property">classmethod </em><code class="descname">atleast</code><span class="sig-paren">(</span><em>lits</em>, <em>bound=1</em>, <em>top_id=None</em>, <em>encoding=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.CardEnc.atleast" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be used for creating a CNF encoding of an AtLeastK
constraint, i.e. of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\geq k\)</span>. The method
takes 1 mandatory argument <code class="docutils literal notranslate"><span class="pre">lits</span></code> and 3 default arguments can be
specified: <code class="docutils literal notranslate"><span class="pre">bound</span></code>, <code class="docutils literal notranslate"><span class="pre">top_id</span></code>, and <code class="docutils literal notranslate"><span class="pre">encoding</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lits</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a list of literals in the sum.</li>
<li><strong>bound</strong> (<em>int</em>) – the value of bound <span class="math notranslate nohighlight">\(k\)</span>.</li>
<li><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – top variable identifier used so far.</li>
<li><strong>encoding</strong> (<em>integer</em>) – identifier of the encoding to use.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">top_id</span></code> serves to increase integer identifiers of
auxiliary variables introduced during the encoding process. This is
helpful when augmenting an existing CNF formula with the new
cardinality encoding to make sure there is no collision between
identifiers of the variables. If specified the identifiers of the
first auxiliary variable will be <code class="docutils literal notranslate"><span class="pre">top_id+1</span></code>.</p>
<p>The default value of <code class="docutils literal notranslate"><span class="pre">encoding</span></code> is <code class="xref py py-attr docutils literal notranslate"><span class="pre">Enctype.seqcounter</span></code>.</p>
<p>The method <em>translates</em> the AtLeast constraint into an AtMost
constraint by <em>negating</em> the literals of <code class="docutils literal notranslate"><span class="pre">lits</span></code>, creating a new
bound <span class="math notranslate nohighlight">\(n-k\)</span> and invoking <a class="reference internal" href="#pysat.card.CardEnc.atmost" title="pysat.card.CardEnc.atmost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atmost()</span></code></a> with the
modified list of literals and the new bound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="#pysat.card.NoSuchEncodingError" title="pysat.card.NoSuchEncodingError"><strong>NoSuchEncodingError</strong></a> – if encoding does not exist.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">a <a class="reference internal" href="formula.html#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> object where the new             clauses (or the new native atmost constraint) are stored.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pysat.card.CardEnc.atmost">
<em class="property">classmethod </em><code class="descname">atmost</code><span class="sig-paren">(</span><em>lits</em>, <em>bound=1</em>, <em>top_id=None</em>, <em>encoding=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.CardEnc.atmost" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be used for creating a CNF encoding of an AtMostK
constraint, i.e. of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\leq k\)</span>. The method
shares the arguments and the return type with method
<a class="reference internal" href="#pysat.card.CardEnc.atleast" title="pysat.card.CardEnc.atleast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atleast()</span></code></a>. Please, see it for details.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pysat.card.CardEnc.equals">
<em class="property">classmethod </em><code class="descname">equals</code><span class="sig-paren">(</span><em>lits</em>, <em>bound=1</em>, <em>top_id=None</em>, <em>encoding=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.CardEnc.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be used for creating a CNF encoding of an EqualsK
constraint, i.e. of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}= k\)</span>. The method
makes consecutive calls of both <a class="reference internal" href="#pysat.card.CardEnc.atleast" title="pysat.card.CardEnc.atleast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atleast()</span></code></a> and
<a class="reference internal" href="#pysat.card.CardEnc.atmost" title="pysat.card.CardEnc.atmost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atmost()</span></code></a>. It shares the arguments and the return type
with method <a class="reference internal" href="#pysat.card.CardEnc.atleast" title="pysat.card.CardEnc.atleast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atleast()</span></code></a>. Please, see it for details.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysat.card.EncType">
<em class="property">class </em><code class="descclassname">pysat.card.</code><code class="descname">EncType</code><a class="headerlink" href="#pysat.card.EncType" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a C-like <code class="docutils literal notranslate"><span class="pre">enum</span></code> type for choosing the
cardinality encoding to use. The values denoting the encodings are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pairwise</span>    <span class="o">=</span> <span class="mi">0</span>
<span class="n">seqcounter</span>  <span class="o">=</span> <span class="mi">1</span>
<span class="n">sortnetwrk</span>  <span class="o">=</span> <span class="mi">2</span>
<span class="n">cardnetwrk</span>  <span class="o">=</span> <span class="mi">3</span>
<span class="n">bitwise</span>     <span class="o">=</span> <span class="mi">4</span>
<span class="n">ladder</span>      <span class="o">=</span> <span class="mi">5</span>
<span class="n">totalizer</span>   <span class="o">=</span> <span class="mi">6</span>
<span class="n">mtotalizer</span>  <span class="o">=</span> <span class="mi">7</span>
<span class="n">kmtotalizer</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">native</span>      <span class="o">=</span> <span class="mi">9</span>
</pre></div>
</div>
<p>The desired encoding can be selected either directly by its integer
identifier, e.g. <code class="docutils literal notranslate"><span class="pre">2</span></code>, or by its alphabetical name, e.g.
<code class="docutils literal notranslate"><span class="pre">EncType.sortnetwrk</span></code>.</p>
<p>Note that while most of the encodings are produced as a list of
clauses, the “native” encoding of <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard</a> is managed as one clause.
Given an AtMostK constraint <span class="math notranslate nohighlight">\(\sum_{i=1}^n{x_i\leq k}\)</span>, the native
encoding represents it as a pair <code class="docutils literal notranslate"><span class="pre">[lits,</span> <span class="pre">k]</span></code>, where <code class="docutils literal notranslate"><span class="pre">lits</span></code> is a
list of size <code class="docutils literal notranslate"><span class="pre">n</span></code> containing literals in the sum.</p>
</dd></dl>

<dl class="class">
<dt id="pysat.card.ITotalizer">
<em class="property">class </em><code class="descclassname">pysat.card.</code><code class="descname">ITotalizer</code><span class="sig-paren">(</span><em>lits=[]</em>, <em>ubound=1</em>, <em>top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer" title="Permalink to this definition">¶</a></dt>
<dd><p>This class implements the iterative totalizer encoding <a class="footnote-reference" href="#id24" id="id25">[11]</a>. Note that
<a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> can be used only for creating AtMostK constraints.
In contrast to class <a class="reference internal" href="#pysat.card.EncType" title="pysat.card.EncType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EncType</span></code></a>, this class is not abstract and
its objects once created can be reused several times. The idea is that
a <em>totalizer tree</em> can be extended, or the bound can be increased, as
well as two totalizer trees can be merged into one.</p>
<p>The constructor of the class object takes 3 default arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lits</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a list of literals to sum.</li>
<li><strong>ubound</strong> (<em>int</em>) – the largest potential bound to use.</li>
<li><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – top variable identifier used so far.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The encoding of the current tree can be accessed with the use of
<a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> variable stored as <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. Potential bounds <strong>are
not</strong> imposed by default but can be added as unit clauses in the final
CNF formula. The bounds are stored in the list of Boolean variables as
<code class="docutils literal notranslate"><span class="pre">self.rhs</span></code>. A concrete bound <span class="math notranslate nohighlight">\(k\)</span> can be enforced by considering
a unit clause <code class="docutils literal notranslate"><span class="pre">-self.rhs[k]</span></code>. <strong>Note</strong> that <code class="docutils literal notranslate"><span class="pre">-self.rhs[0]</span></code> enforces
all literals of the sum to be <em>false</em>.</p>
<p>An <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object should be deleted if it is not needed
anymore.</p>
<p>Possible usage of the class is shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[6, 7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively, an object can be created using the <code class="docutils literal notranslate"><span class="pre">with</span></code> keyword. In
this case, the object is deleted automatically:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7]]</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[6, 7]</span>
</pre></div>
</div>
<dl class="method">
<dt id="pysat.card.ITotalizer.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroys a previously constructed <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object.
Internal variables <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code> and <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code> get cleaned.</p>
</dd></dl>

<dl class="method">
<dt id="pysat.card.ITotalizer.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>lits=[]</em>, <em>ubound=None</em>, <em>top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends the list of literals in the sum and (if needed) increases a
potential upper bound that can be imposed on the complete list of
literals in the sum of an existing <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object to a
new value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lits</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – additional literals to be included in the sum.</li>
<li><strong>ubound</strong> (<em>int</em>) – a new upper bound.</li>
<li><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – a new top variable identifier.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The top identifier <code class="docutils literal notranslate"><span class="pre">top_id</span></code> applied only if it is greater than
the one used in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method creates additional clauses encoding the existing
totalizer tree augmented with new literals in the sum and updating
the upper bound. As a result, it appends the new clauses to the
list of clauses of <a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. The number of newly
created clauses is stored in variable <code class="docutils literal notranslate"><span class="pre">self.nof_new</span></code>.</p>
<p>Also, if the upper bound is updated, a list of bounds <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code>
gets increased and its length becomes <code class="docutils literal notranslate"><span class="pre">ubound+1</span></code>. Otherwise, it
is updated with new values.</p>
<p>The method can be used in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[3, 4]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4], [-5, 6], [-3, 6], [-4, 7], [-3, -5, 7], [-4, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">nof_new</span><span class="p">:]</span>
<span class="go">[[-5, 6], [-3, 6], [-4, 7], [-3, -5, 7], [-4, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[6, 7, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.card.ITotalizer.increase">
<code class="descname">increase</code><span class="sig-paren">(</span><em>ubound=1</em>, <em>top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.increase" title="Permalink to this definition">¶</a></dt>
<dd><p>Increases a potential upper bound that can be imposed on the
literals in the sum of an existing <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object to a
new value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ubound</strong> (<em>int</em>) – a new upper bound.</li>
<li><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – a new top variable identifier.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The top identifier <code class="docutils literal notranslate"><span class="pre">top_id</span></code> applied only if it is greater than
the one used in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method creates additional clauses encoding the existing
totalizer tree up to the new upper bound given and appends them to
the list of clauses of <a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. The number of
newly created clauses is stored in variable <code class="docutils literal notranslate"><span class="pre">self.nof_new</span></code>.</p>
<p>Also, a list of bounds <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code> gets increased and its length
becomes <code class="docutils literal notranslate"><span class="pre">ubound+1</span></code>.</p>
<p>The method can be used in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[6, 7]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">increase</span><span class="p">(</span><span class="n">ubound</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7], [-3, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">nof_new</span><span class="p">:]</span>
<span class="go">[[-3, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[6, 7, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.card.ITotalizer.merge_with">
<code class="descname">merge_with</code><span class="sig-paren">(</span><em>another</em>, <em>ubound=None</em>, <em>top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.merge_with" title="Permalink to this definition">¶</a></dt>
<dd><p>This method merges a tree of the current <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a>
object, with a tree of another object and (if needed) increases a
potential upper bound that can be imposed on the complete list of
literals in the sum of an existing <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object to a
new value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>another</strong> (<a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a>) – another totalizer to merge with.</li>
<li><strong>ubound</strong> (<em>int</em>) – a new upper bound.</li>
<li><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – a new top variable identifier.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The top identifier <code class="docutils literal notranslate"><span class="pre">top_id</span></code> applied only if it is greater than
the one used in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method creates additional clauses encoding the existing
totalizer tree merged with another totalizer tree into <em>one</em> sum
and updating the upper bound. As a result, it appends the new
clauses to the list of clauses of <a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. The
number of newly created clauses is stored in variable
<code class="docutils literal notranslate"><span class="pre">self.nof_new</span></code>.</p>
<p>Also, if the upper bound is updated, a list of bounds <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code>
gets increased and its length becomes <code class="docutils literal notranslate"><span class="pre">ubound+1</span></code>. Otherwise, it
is updated with new values.</p>
<p>The method can be used in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">t1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4]]</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">t1</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[3, 4]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">t2</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-6, 7], [-5, 7], [-5, -6, 8]]</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">t1</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[7, 8]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">t1</span><span class="o">.</span><span class="n">merge_with</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4], [-6, 7], [-5, 7], [-5, -6, 8], [-7, 9], [-8, 10], [-3, 9], [-4, 10], [-3, -7, 10]]</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="o">-</span><span class="n">t1</span><span class="o">.</span><span class="n">nof_new</span><span class="p">:]</span>
<span class="go">[[-6, 7], [-5, 7], [-5, -6, 8], [-7, 9], [-8, 10], [-3, 9], [-4, 10], [-3, -7, 10]]</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">t1</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[9, 10]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">t2</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysat.card.ITotalizer.new">
<code class="descname">new</code><span class="sig-paren">(</span><em>lits=[]</em>, <em>ubound=1</em>, <em>top_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.new" title="Permalink to this definition">¶</a></dt>
<dd><p>The actual constructor of <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a>. Invoked from
<code class="docutils literal notranslate"><span class="pre">self.__init__()</span></code>. Creates an object of <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> given
a list of literals in the sum, the largest potential bound to
consider, as well as the top variable identifier used so far. See
the description of <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> for details.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pysat.card.NoSuchEncodingError">
<em class="property">exception </em><code class="descclassname">pysat.card.</code><code class="descname">NoSuchEncodingError</code><a class="headerlink" href="#pysat.card.NoSuchEncodingError" title="Permalink to this definition">¶</a></dt>
<dd><p>This exception is raised when creating an unknown an AtMostk, AtLeastK,
or EqualK constraint encoding.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/pysat.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pysathq&repo=pysat&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div class="sidebarblock">
    <div class="tile">
    <h4>Latest version:</h4>
    0.1.3.dev11 (<a href="https://github.com/pysathq/pysat">GitHub</a>)
    </div>
    </br>
</div>
<div class="sidebarblock">
    <div class="tile">
    <h4><a href="https://pysathq.github.io">Main webpage</a></h4>
    </div>
</div>
</br>
<div class="sidebarblock">
<h4>Contact us:</h4>
      <a class="reference external" href="https://github.com/pysathq/pysat/issues">
            Issue tracker
      </a>
      |
      <a class="reference external" href="mailto:pysathq@gmail.com">
          Email
      </a>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/api/card.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>